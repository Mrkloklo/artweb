{"remainingRequest":"/Users/gujiahao/Documents/work/github/artweb/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/gujiahao/Documents/work/github/artweb/src/components/gridunlock.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/gujiahao/Documents/work/github/artweb/src/components/gridunlock.vue","mtime":1588230106505},{"path":"/Users/gujiahao/Documents/work/github/artweb/node_modules/cache-loader/dist/cjs.js","mtime":1579587180818},{"path":"/Users/gujiahao/Documents/work/github/artweb/node_modules/babel-loader/lib/index.js","mtime":1585810045725},{"path":"/Users/gujiahao/Documents/work/github/artweb/node_modules/cache-loader/dist/cjs.js","mtime":1579587180818},{"path":"/Users/gujiahao/Documents/work/github/artweb/node_modules/vue-loader/lib/index.js","mtime":1585810053320}],"contextDependencies":[],"result":["//\n//\n//\n//\n\nexport default {\n  name: 'GridUnlock',\n  props: {\n    r: {\n      type: Number,\n      default: 26\n    },\n    cw: {\n      type: Number,\n      default: window.screen.width\n    },\n    ch: {\n      type: Number,\n      default: 320\n    },\n    outRoundBorderColor: {\n      type: String,\n      default: '#666'\n    },\n    lineWidth: {\n      type: Number,\n      default: 3\n    },\n    lineColor: {\n      type: String,\n      default: '#f00'\n    },\n    outRoundColor: {\n      type: String,\n      default: '#fff'\n    },\n    innerRoundColor: {\n      type: String,\n      default: '#008080'\n    },\n    offsetX: {\n      type: Number,\n      default: 15\n    },\n    offsetY: {\n      type: Number,\n      default: 15\n    }\n  },\n  data () {\n    return {\n      pointArr: [],\n      offsetTop: 0,\n      ctx: null\n    };\n  },\n  methods: {\n    _initGridunlock () {\n      const { canvas } = this.$refs;\n      const ctx = canvas.getContext('2d');\n\n      this.ctx = ctx;\n      this.offsetTop = this._getOffsetTop(canvas) || 0;\n      this.pointArr = this._drawLocalPoint((this.cw - 2 * this.offsetX - this.r * 2 * 3) / 2, (this.ch - 2 * this.offsetY - this.r * 2 * 3) / 2);\n      this._initListeners(canvas, ctx);\n      this._draw(this.pointArr, [], null, ctx);\n    },\n\n    _getOffsetTop (canvas) {\n      let offsetTop = 0;\n      let { parentElement } = canvas;\n\n      while (parentElement && parentElement.nodeType === 1 && parentElement.tagName !== 'body') {\n        offsetTop += parentElement.offsetTop;\n        parentElement = parentElement.parentElement;\n      }\n\n      return offsetTop;\n    },\n\n    /**\n     * 计算画布9个点\n     * @param {Number} x 坐标\n     * @param {Number} y 坐标\n     * @returns {Array} result 坐标数组\n     * @private\n     */\n    _drawLocalPoint (x, y) {\n      const result = [];\n      const { offsetX } = this;\n      const { offsetY } = this;\n      const { r } = this;\n\n      for (let row = 0; row < 3; row++) {\n        for (let col = 0; col < 3; col++) {\n          const ninePoint = {\n            x: (offsetX + col * x + (col * 2 + 1) * r),\n            y: (offsetY + row * y + (row * 2 + 1) * r)\n          };\n\n          result.push(ninePoint);\n        }\n      }\n\n      return result;\n    },\n\n    /**\n     * @param {HTMLElement} canvas el\n     * @param {Object} ctx CanvasRenderingContext2D\n     * @private\n     */\n    _initListeners (canvas, ctx) {\n      let linePoint = [];\n      const { cw } = this;\n      const { ch } = this;\n\n      canvas.addEventListener('touchstart', (e) => {\n        e.preventDefault();\n        this._selectPoint(e.touches[0], linePoint);\n      }, {\n        passive: false\n      });\n\n      canvas.addEventListener('touchmove', (e) => {\n        e.preventDefault();\n\n        const touches = e.touches[0];\n\n        this._selectPoint(touches, linePoint);\n\n        ctx.clearRect(0, 0, cw, ch);\n\n        this._draw(this.pointArr, linePoint, {\n          x: touches.pageX,\n          y: touches.pageY - this.offsetTop\n        }, ctx);\n      }, {\n        passive: false\n      });\n\n      canvas.addEventListener('touchend', (e) => {\n        ctx.clearRect(0, 0, cw, ch);\n        this._draw(this.pointArr, linePoint, null, ctx);\n        this.$emit('success', linePoint);\n        linePoint = [];\n      });\n    },\n\n    /**\n     * 选点\n     * @param {event} touches 坐标\n     * @param {Array} LinePoint 已选择的点\n     * @private\n     */\n    _selectPoint (touches, LinePoint) {\n      const { pointArr } = this;\n\n      for (let i = 0, len = pointArr.length; i < len; i++) {\n        const curPoint = pointArr[i];\n        const xDiff = Math.abs(curPoint.x - touches.pageX);\n        const yDiff = Math.abs(curPoint.y - (touches.pageY - this.offsetTop));\n        const dir = Math.pow((xDiff * xDiff + yDiff * yDiff), 0.5);\n\n        if (dir < this.r) {\n          if (LinePoint.indexOf(i) < 0) {\n            LinePoint.push(i);\n          }\n          break;\n        }\n      }\n    },\n\n    /**\n     * 绘制圆点\n     * @param {Array} pointArr 画布9个点\n     * @param {Array} linePointArr 存储已连点\n     * @param {Object} touchPoint 触摸点\n     * @param {Object} ctx canvas画笔\n     * @private\n     */\n    _draw (pointArr, linePointArr, touchPoint, ctx) {\n      const { r } = this;\n      const pI2 = Math.PI * 2;\n\n      if (linePointArr.length > 0) {\n        ctx.beginPath();\n        for (let i = 0, len = linePointArr.length; i < len; i++) {\n          const index = linePointArr[i];\n\n          ctx.lineTo(pointArr[index].x, pointArr[index].y);\n        }\n\n        ctx.lineWidth = this.lineWidth;\n        ctx.strokeStyle = this.lineColor;\n        ctx.stroke();\n        ctx.closePath();\n\n        if (touchPoint) {\n          const lastIndex = linePointArr[linePointArr.length - 1];\n          const lastPoint = pointArr[lastIndex];\n\n          ctx.beginPath();\n          ctx.moveTo(lastPoint.x, lastPoint.y);\n          ctx.lineTo(touchPoint.x, touchPoint.y);\n          ctx.stroke();\n          ctx.closePath();\n        }\n      }\n\n      for (let i = 0, len = pointArr.length; i < len; i++) {\n        const point = pointArr[i];\n\n        ctx.fillStyle = this.outRoundBorderColor;\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, r, 0, pI2, true);\n        ctx.closePath();\n\n        ctx.fill();\n        ctx.fillStyle = this.outRoundColor;\n\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, r - 3, 0, pI2, true);\n        ctx.closePath();\n        ctx.fill();\n\n        if (linePointArr.indexOf(i) >= 0) {\n          ctx.fillStyle = this.innerRoundColor;\n          ctx.beginPath();\n          ctx.arc(point.x, point.y, r - 16, 0, pI2, true);\n          ctx.closePath();\n          ctx.fill();\n        }\n      }\n    },\n\n    reset () {\n      this.ctx.clearRect(0, 0, this.cw, this.ch);\n    }\n  },\n  mounted () {\n    this._initGridunlock();\n  }\n};\n",{"version":3,"sources":["gridunlock.vue"],"names":[],"mappings":";;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"gridunlock.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <canvas :width=\"cw\" :height=\"ch\" ref=\"canvas\"></canvas>\n</template>\n\n<script>\nexport default {\n  name: 'GridUnlock',\n  props: {\n    r: {\n      type: Number,\n      default: 26\n    },\n    cw: {\n      type: Number,\n      default: window.screen.width\n    },\n    ch: {\n      type: Number,\n      default: 320\n    },\n    outRoundBorderColor: {\n      type: String,\n      default: '#666'\n    },\n    lineWidth: {\n      type: Number,\n      default: 3\n    },\n    lineColor: {\n      type: String,\n      default: '#f00'\n    },\n    outRoundColor: {\n      type: String,\n      default: '#fff'\n    },\n    innerRoundColor: {\n      type: String,\n      default: '#008080'\n    },\n    offsetX: {\n      type: Number,\n      default: 15\n    },\n    offsetY: {\n      type: Number,\n      default: 15\n    }\n  },\n  data () {\n    return {\n      pointArr: [],\n      offsetTop: 0,\n      ctx: null\n    };\n  },\n  methods: {\n    _initGridunlock () {\n      const { canvas } = this.$refs;\n      const ctx = canvas.getContext('2d');\n\n      this.ctx = ctx;\n      this.offsetTop = this._getOffsetTop(canvas) || 0;\n      this.pointArr = this._drawLocalPoint((this.cw - 2 * this.offsetX - this.r * 2 * 3) / 2, (this.ch - 2 * this.offsetY - this.r * 2 * 3) / 2);\n      this._initListeners(canvas, ctx);\n      this._draw(this.pointArr, [], null, ctx);\n    },\n\n    _getOffsetTop (canvas) {\n      let offsetTop = 0;\n      let { parentElement } = canvas;\n\n      while (parentElement && parentElement.nodeType === 1 && parentElement.tagName !== 'body') {\n        offsetTop += parentElement.offsetTop;\n        parentElement = parentElement.parentElement;\n      }\n\n      return offsetTop;\n    },\n\n    /**\n     * 计算画布9个点\n     * @param {Number} x 坐标\n     * @param {Number} y 坐标\n     * @returns {Array} result 坐标数组\n     * @private\n     */\n    _drawLocalPoint (x, y) {\n      const result = [];\n      const { offsetX } = this;\n      const { offsetY } = this;\n      const { r } = this;\n\n      for (let row = 0; row < 3; row++) {\n        for (let col = 0; col < 3; col++) {\n          const ninePoint = {\n            x: (offsetX + col * x + (col * 2 + 1) * r),\n            y: (offsetY + row * y + (row * 2 + 1) * r)\n          };\n\n          result.push(ninePoint);\n        }\n      }\n\n      return result;\n    },\n\n    /**\n     * @param {HTMLElement} canvas el\n     * @param {Object} ctx CanvasRenderingContext2D\n     * @private\n     */\n    _initListeners (canvas, ctx) {\n      let linePoint = [];\n      const { cw } = this;\n      const { ch } = this;\n\n      canvas.addEventListener('touchstart', (e) => {\n        e.preventDefault();\n        this._selectPoint(e.touches[0], linePoint);\n      }, {\n        passive: false\n      });\n\n      canvas.addEventListener('touchmove', (e) => {\n        e.preventDefault();\n\n        const touches = e.touches[0];\n\n        this._selectPoint(touches, linePoint);\n\n        ctx.clearRect(0, 0, cw, ch);\n\n        this._draw(this.pointArr, linePoint, {\n          x: touches.pageX,\n          y: touches.pageY - this.offsetTop\n        }, ctx);\n      }, {\n        passive: false\n      });\n\n      canvas.addEventListener('touchend', (e) => {\n        ctx.clearRect(0, 0, cw, ch);\n        this._draw(this.pointArr, linePoint, null, ctx);\n        this.$emit('success', linePoint);\n        linePoint = [];\n      });\n    },\n\n    /**\n     * 选点\n     * @param {event} touches 坐标\n     * @param {Array} LinePoint 已选择的点\n     * @private\n     */\n    _selectPoint (touches, LinePoint) {\n      const { pointArr } = this;\n\n      for (let i = 0, len = pointArr.length; i < len; i++) {\n        const curPoint = pointArr[i];\n        const xDiff = Math.abs(curPoint.x - touches.pageX);\n        const yDiff = Math.abs(curPoint.y - (touches.pageY - this.offsetTop));\n        const dir = Math.pow((xDiff * xDiff + yDiff * yDiff), 0.5);\n\n        if (dir < this.r) {\n          if (LinePoint.indexOf(i) < 0) {\n            LinePoint.push(i);\n          }\n          break;\n        }\n      }\n    },\n\n    /**\n     * 绘制圆点\n     * @param {Array} pointArr 画布9个点\n     * @param {Array} linePointArr 存储已连点\n     * @param {Object} touchPoint 触摸点\n     * @param {Object} ctx canvas画笔\n     * @private\n     */\n    _draw (pointArr, linePointArr, touchPoint, ctx) {\n      const { r } = this;\n      const pI2 = Math.PI * 2;\n\n      if (linePointArr.length > 0) {\n        ctx.beginPath();\n        for (let i = 0, len = linePointArr.length; i < len; i++) {\n          const index = linePointArr[i];\n\n          ctx.lineTo(pointArr[index].x, pointArr[index].y);\n        }\n\n        ctx.lineWidth = this.lineWidth;\n        ctx.strokeStyle = this.lineColor;\n        ctx.stroke();\n        ctx.closePath();\n\n        if (touchPoint) {\n          const lastIndex = linePointArr[linePointArr.length - 1];\n          const lastPoint = pointArr[lastIndex];\n\n          ctx.beginPath();\n          ctx.moveTo(lastPoint.x, lastPoint.y);\n          ctx.lineTo(touchPoint.x, touchPoint.y);\n          ctx.stroke();\n          ctx.closePath();\n        }\n      }\n\n      for (let i = 0, len = pointArr.length; i < len; i++) {\n        const point = pointArr[i];\n\n        ctx.fillStyle = this.outRoundBorderColor;\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, r, 0, pI2, true);\n        ctx.closePath();\n\n        ctx.fill();\n        ctx.fillStyle = this.outRoundColor;\n\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, r - 3, 0, pI2, true);\n        ctx.closePath();\n        ctx.fill();\n\n        if (linePointArr.indexOf(i) >= 0) {\n          ctx.fillStyle = this.innerRoundColor;\n          ctx.beginPath();\n          ctx.arc(point.x, point.y, r - 16, 0, pI2, true);\n          ctx.closePath();\n          ctx.fill();\n        }\n      }\n    },\n\n    reset () {\n      this.ctx.clearRect(0, 0, this.cw, this.ch);\n    }\n  },\n  mounted () {\n    this._initGridunlock();\n  }\n};\n</script>\n\n<style scoped>\n\n</style>\n"]}]}