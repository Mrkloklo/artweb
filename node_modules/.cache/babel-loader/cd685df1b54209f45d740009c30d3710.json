{"remainingRequest":"/Users/gujiahao/Documents/work/github/artweb/node_modules/thread-loader/dist/cjs.js!/Users/gujiahao/Documents/work/github/artweb/node_modules/babel-loader/lib/index.js!/Users/gujiahao/Documents/work/github/artweb/node_modules/@vue/cli-plugin-eslint/node_modules/eslint-loader/index.js??ref--13-0!/Users/gujiahao/Documents/work/github/artweb/public/ejs/v3/ejs.js","dependencies":[{"path":"/Users/gujiahao/Documents/work/github/artweb/public/ejs/v3/ejs.js","mtime":1588230106466},{"path":"/Users/gujiahao/Documents/work/github/artweb/node_modules/cache-loader/dist/cjs.js","mtime":1579587180818},{"path":"/Users/gujiahao/Documents/work/github/artweb/node_modules/thread-loader/dist/cjs.js","mtime":1579587183081},{"path":"/Users/gujiahao/Documents/work/github/artweb/node_modules/babel-loader/lib/index.js","mtime":1585810045725},{"path":"/Users/gujiahao/Documents/work/github/artweb/node_modules/@vue/cli-plugin-eslint/node_modules/eslint-loader/index.js","mtime":1579587173378}],"contextDependencies":[],"result":["import \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es6.number.constructor\";\nimport \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es6.regexp.match\";\nimport _typeof from \"/Users/gujiahao/Documents/work/github/artweb/node_modules/@babel/runtime-corejs2/helpers/esm/typeof\";\n\n/*!\n * ejsv3 v3.2.6d\n * (c) 2017-2019 \n * Released under the BSD-3-Clause License.\n * \n */\n(function (global, factory) {\n  (typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.ejs = factory();\n})(window, function () {\n  'use strict';\n  /**\n   * 加入系统判断功能\n   */\n\n  function osMixin(hybrid) {\n    var hybridJs = hybrid;\n\n    var detect = function detect(ua) {\n      this.os = {};\n      var android = ua.match(/(Android);?[\\s/]+([\\d.]+)?/);\n\n      if (android) {\n        this.os.android = true;\n        this.os.version = android[2];\n        this.os.isBadAndroid = !/Chrome\\/\\d/.test(window.navigator.appVersion);\n      }\n\n      var iphone = ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n\n      if (iphone) {\n        this.os.ios = true;\n        this.os.iphone = true;\n        this.os.version = iphone[2].replace(/_/g, '.');\n      }\n\n      var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n\n      if (ipad) {\n        this.os.ios = true;\n        this.os.ipad = true;\n        this.os.version = ipad[2].replace(/_/g, '.');\n      } // epoint的容器\n\n\n      var ejs = ua.match(/EpointEJS/i);\n\n      if (ejs) {\n        this.os.ejs = true;\n      }\n\n      var dd = ua.match(/DingTalk/i);\n\n      if (dd) {\n        this.os.dd = true;\n      } // 如果ejs和钉钉都不是，则默认为h5\n\n\n      if (!ejs && !dd) {\n        this.os.h5 = true;\n      }\n    };\n\n    detect.call(hybridJs, navigator.userAgent);\n  }\n  /**\n   * 不用polyfill，避免体积增大\n   */\n\n\n  function promiseMixin(hybrid) {\n    var hybridJs = hybrid; // 暂时去除默认的promise支持，防止普通开发人员不会使用导致报错无法补货\n    // hybridJs.Promise = window.Promise;\n\n    hybridJs.getPromise = function () {\n      return hybridJs.Promise;\n    };\n\n    hybridJs.setPromise = function (newPromise) {\n      hybridJs.Promise = newPromise;\n    };\n  }\n\n  var globalError = {\n    /**\n     * 1001 api os错误\n     */\n    ERROR_TYPE_APIOS: {\n      code: 1001,\n      // 这个只是默认的提示，如果没有新的提示，就会采用默认的提示\n      msg: '该API无法在当前OS下运行'\n    },\n\n    /**\n     * 1002 api modify错误\n     */\n    ERROR_TYPE_APIMODIFY: {\n      code: 1002,\n      msg: '不允许更改JSSDK的API'\n    },\n\n    /**\n     * 1003 module modify错误\n     */\n    ERROR_TYPE_MODULEMODIFY: {\n      code: 1003,\n      msg: '不允许更改JSSDK的模块'\n    },\n\n    /**\n     * 1004 api 不存在\n     */\n    ERROR_TYPE_APINOTEXIST: {\n      code: 1004,\n      msg: '调用了不存在的api'\n    },\n\n    /**\n     * 1005 组件api对应的proto不存在\n     */\n    ERROR_TYPE_PROTONOTEXIST: {\n      code: 1005,\n      msg: '调用错误，该组件api对应的proto不存在'\n    },\n\n    /**\n     * 1006 非容器环境下无法调用自定义组件API\n     */\n    ERROR_TYPE_CUSTOMEAPINOTEXIST: {\n      code: 1006,\n      msg: '非容器下无法调用自定义组件API'\n    },\n\n    /**\n     * 1007 对应的event事件在该环境下不存在\n     */\n    ERROR_TYPE_EVENTNOTEXIST: {\n      code: 1007,\n      msg: '对应的event事件在该环境下不存在'\n    },\n\n    /**\n     * 1008 对应的event事件在该环境下不存在\n     */\n    ERROR_TYPE_INITVERSIONERROR: {\n      code: 1008,\n      msg: '初始化版本号错误，请检查容器api的实现情况'\n    },\n\n    /**\n     * 1009 当前容器版本不支持API\n     */\n    ERROR_TYPE_APINEEDHIGHNATIVEVERSION: {\n      code: 1009,\n      msg: '当前API需要更高版本的容器支持'\n    },\n\n    /**\n     * 2001 ready modify错误-ready回调正常只允许定义一个\n     */\n    ERROR_TYPE_READYMODIFY: {\n      code: 2001,\n      msg: 'ready回调不允许多次设置'\n    },\n\n    /**\n     * 2002 config modify错误-正常一个页面只允许config一次\n     */\n    ERROR_TYPE_CONFIGMODIFY: {\n      code: 2002,\n      msg: 'config不允许多次调用'\n    },\n\n    /**\n     * 2003 config 错误\n     */\n    ERROR_TYPE_CONFIGERROR: {\n      code: 2003,\n      msg: 'config校验错误'\n    },\n\n    /**\n     * 2004 version not support\n     */\n    ERROR_TYPE_VERSIONNOTSUPPORT: {\n      code: 2004,\n      msg: '不支持当前容器版本，请确保容器与前端库版本匹配'\n    },\n\n    /**\n     * 2004 version not support\n     */\n    ERROR_TYPE_VERSIONNEEDUPGRADE: {\n      code: 2005,\n      msg: '当前JSSDK库小于容器版本，请将前端库升级到最新版本'\n    },\n\n    /**\n     * 3000 原生错误(非API错误)，原生捕获到的错误都会通知J5\n     */\n    ERROR_TYPE_NATIVE: {\n      code: 3000,\n      msg: '捕获到一处原生容器错误'\n    },\n\n    /**\n     * 3001 原生调用h5错误  原生通过JSBridge调用h5错误，可能是参数不对\n     */\n    ERROR_TYPE_NATIVECALL: {\n      code: 3001,\n      msg: '原生调用H5时参数不对'\n    },\n\n    /**\n     * 9999 其它未知错误\n     */\n    ERROR_TYPE_UNKNOWN: {\n      code: 9999,\n      msg: '未知错误'\n    }\n  };\n\n  function warn(msg) {\n    // 模板字符串\n    console.error(\"[hybridJs error]: \" + msg);\n  }\n\n  function log(msg) {\n    console.log(\"[hybridJs log]: \" + msg);\n  }\n\n  function errorMixin(hybrid) {\n    var hybridJs = hybrid;\n    var errorFunc = void 0;\n    /**\n     * 提示全局错误\n     * @param {Nunber} code 错误代码\n     * @param {String} msg 错误提示\n     */\n\n    function showError() {\n      var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var msg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '错误!';\n      warn('code:' + code + ', msg:' + msg);\n      errorFunc && errorFunc({\n        code: code,\n        message: msg\n      });\n    }\n\n    hybridJs.showError = showError;\n    hybridJs.globalError = globalError;\n    /**\n     * 当出现错误时，会通过这个函数回调给开发者，可以拿到里面的提示信息\n     * @param {Function} callback 开发者设置的回调(每次会监听一个全局error函数)\n     * 回调的参数好似\n     * msg 错误信息\n     * code 错误码\n     */\n\n    hybridJs.error = function error(callback) {\n      errorFunc = callback; // 兼容钉钉\n\n      if (hybridJs.os.dd) {\n        window.dd && dd.error(errorFunc);\n      }\n    };\n  }\n\n  function isObject(object) {\n    var classType = Object.prototype.toString.call(object).match(/^\\[object\\s(.*)\\]$/)[1];\n    return classType !== 'String' && classType !== 'Number' && classType !== 'Boolean' && classType !== 'Undefined' && classType !== 'Null';\n  }\n\n  var noop = function noop() {};\n\n  function extend(target) {\n    var finalTarget = target;\n\n    for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      rest[_key - 1] = arguments[_key];\n    }\n\n    rest.forEach(function (source) {\n      source && Object.keys(source).forEach(function (key) {\n        finalTarget[key] = source[key];\n      });\n    });\n    return finalTarget;\n  }\n  /**\n   * 如果version1大于version2，返回1，如果小于，返回-1，否则返回0。 TODO\n   * @param {string} version1 版本1\n   * @param {string} version2 版本2\n   * @return {number} 返回版本1和版本2的关系\n   */\n\n\n  function compareVersion(version1, version2) {\n    if (typeof version1 !== 'string' || typeof version2 !== 'string') {\n      throw new Error('version need to be string type');\n    }\n\n    var verArr1 = version1.split('.');\n    var verArr2 = version2.split('.');\n    var len = Math.max(verArr1.length, verArr2.length); // forin不推荐，foreach不能return与break\n\n    for (var i = 0; i < len; i += 1) {\n      var ver1 = verArr1[i] || 0;\n      var ver2 = verArr2[i] || 0;\n\n      if (i === 2) {\n        if (isNaN(+ver1)) {\n          ver1 = ver1.slice(0, ver1.length - 1);\n        }\n\n        if (isNaN(+ver2)) {\n          ver2 = ver2.slice(0, ver2.length - 1);\n        }\n      } // 隐式转化为数字\n\n\n      ver1 -= 0;\n      ver2 -= 0;\n\n      if (ver1 > ver2) {\n        return 1;\n      } else if (ver1 < ver2) {\n        return -1;\n      }\n    }\n\n    return 0;\n  }\n  /**\n   * 字符串超出截取\n   * @param {string} str 目标字符串\n   * @param {Number} count 字数，以英文为基数，如果是中文，会自动除2\n   * @return {string} 返回截取后的字符串\n   * 暂时不考虑只遍历一部分的性能问题，因为在应用场景内是微不足道的\n   */\n\n\n  function eclipseText() {\n    var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;\n    var LEN_CHINESE = 2;\n    var LEN_ENGLISH = 1;\n    var num = 0;\n    return str.split('').filter(function (ch) {\n      num += /[\\u4e00-\\u9fa5]/.test(ch) ? LEN_CHINESE : LEN_ENGLISH;\n      return num <= count;\n    }).join('');\n  }\n  /**\n   * 得到一个项目的根路径\n   * h5模式下例如:http://id:端口/项目名/\n   * @return {String} 项目的根路径\n   */\n\n\n  function getProjectBasePath() {\n    var locObj = window.location;\n    var patehName = locObj.pathname;\n    var pathArray = patehName.split('/'); // 如果是 host/xxx.html 则是/，如果是host/project/xxx.html,则是project/\n    // pathName一般是 /context.html 或 /xxx/xx/content.html\n\n    var hasProject = pathArray.length > 2;\n    var contextPath = pathArray[Number(hasProject)] + '/'; // 如果尾部有两个//替换成一个\n\n    return (locObj.protocol + '//' + locObj.host + '/' + contextPath).replace(/[/]{2}$/, '/');\n  }\n  /**\n   * 将相对路径转为绝对路径 ./ ../ 开头的  为相对路径\n   * 会基于对应调用js的html路径去计算\n   * @param {String} path 需要转换的路径\n   * @return {String} 返回转换后的路径\n   */\n\n\n  function changeRelativePathToAbsolute(path) {\n    var locObj = window.location;\n    var patehName = locObj.pathname; // 匹配相对路径返回父级的个数\n\n    var relatives = path.match(/\\.\\.\\//g);\n    var count = relatives && relatives.length || 0; // 将patehName拆为数组，然后计算当前的父路径，需要去掉相应相对路径的层级\n\n    var pathArray = patehName.split('/');\n    var parentPath = pathArray.slice(0, pathArray.length - (count + 1)).join('/');\n    var childPath = path.replace(/\\.+\\//g, ''); // 找到最后的路径， 通过正则 去除 ./ 之前的所有路径\n\n    var finalPath = parentPath + '/' + childPath;\n    finalPath = locObj.protocol + '//' + locObj.host + finalPath;\n    return finalPath;\n  }\n  /**\n   * 得到一个全路径\n   * @param {String} path 路径\n   * @return {String} 返回最终的路径\n   */\n\n\n  function getFullPath(path) {\n    // 全路径\n    if (/^(http|https|ftp|\\/\\/)/g.test(path)) {\n      return path;\n    } // 是否是相对路径\n\n\n    var isRelative = /(\\.\\/)|(\\.\\.\\/)/.test(path);\n\n    if (isRelative) {\n      return changeRelativePathToAbsolute(path);\n    }\n\n    return '' + getProjectBasePath() + path;\n  }\n  /**\n   * 将json参数拼接到url中\n   * @param {String} url url地址\n   * @param {Object} data 需要添加的json数据\n   * @return {String} 返回最终的url\n   */\n\n\n  function getFullUrlByParams() {\n    var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var data = arguments[1];\n    var fullUrl = getFullPath(url);\n    var extrasDataStr = '';\n\n    if (data) {\n      Object.keys(data).forEach(function (item) {\n        if (extrasDataStr.indexOf('?') === -1 && fullUrl.indexOf('?') === -1) {\n          extrasDataStr += '?';\n        } else {\n          extrasDataStr += '&';\n        }\n\n        extrasDataStr += item + '=' + data[item];\n      });\n    }\n\n    fullUrl += extrasDataStr;\n    return fullUrl;\n  }\n  /**\n   * 获取 base64 去除 url 部分\n   * @param {String} base64 base64值\n   * @returns {String} 该 base64 去除 url 后的值\n   */\n\n\n  function getBase64NotUrl(base64) {\n    return base64.replace(/^data.*,/, '');\n  }\n  /**\n   * 依赖于以下的基础库\n   * Promise\n   */\n\n\n  function proxyMixin(hybrid) {\n    var hybridJs = hybrid;\n    var globalError = hybridJs.globalError;\n    /**\n     * 对所有的API进行统一参数预处理，promise逻辑支持等操作\n     * @param {Object} api 对应的API\n     * @param {Function} callback 回调\n     * @constructor\n     */\n\n    function Proxy(api, callback) {\n      this.api = api;\n      this.callback = callback;\n    }\n    /**\n     * 实际的代理操作\n     */\n\n\n    Proxy.prototype.walk = function walk() {\n      var _this = this; // 实时获取promise\n\n\n      var Promise = hybridJs.getPromise(); // 返回一个闭包函数\n\n      return function () {\n        for (var _len = arguments.length, rest = Array(_len), _key = 0; _key < _len; _key++) {\n          rest[_key] = arguments[_key];\n        }\n\n        var args = rest;\n        args[0] = args[0] || {}; // 默认参数的处理\n\n        if (_this.api.defaultParams && args[0] instanceof Object) {\n          Object.keys(_this.api.defaultParams).forEach(function (item) {\n            if (args[0][item] === undefined) {\n              args[0][item] = _this.api.defaultParams[item];\n            }\n          });\n        } // 决定是否使用Promise\n\n\n        var finallyCallback = void 0;\n\n        if (_this.callback) {\n          // 将this指针修正为proxy内部，方便直接使用一些api关键参数\n          finallyCallback = _this.callback;\n        }\n\n        if (_this.api.support && hybridJs.nativeVersion && compareVersion(hybridJs.nativeVersion, _this.api.support) < 0) {\n          // 如果当前版本还不支持API\n          // 实际上也可以在原生容器进行检测，这里由于遗留问题，改为前端进行\n          var msg = _this.api.namespace + \"\\u8981\\u6C42\\u7684\\u5BB9\\u5668\\u7248\\u672C\\u81F3\\u5C11\\u4E3A:\" + _this.api.support + \"\\uFF0C\\u5F53\\u524D\\u5BB9\\u5668\\u7248\\u672C\\uFF1A\" + hybridJs.nativeVersion + \"\\uFF0C\\u8BF7\\u5347\\u7EA7\";\n          var errorTips = {\n            code: globalError.ERROR_TYPE_APINEEDHIGHNATIVEVERSION.code,\n            msg: msg\n          };\n\n          if (hybridJs.ui && typeof hybridJs.ui.toast === 'function') {\n            hybridJs.ui.toast(msg);\n          } // 不满足要求，直接走错误回调，内部走错误\n\n\n          finallyCallback = function finallyCallback() {\n            var len = arguments.length;\n            var options = arguments.length <= 0 ? undefined : arguments[0];\n            var reject = void 0;\n\n            if (Promise) {\n              reject = arguments.length <= len - 1 ? undefined : arguments[len - 1];\n            } // 如果存在错误回调\n\n\n            options.error && options.error(errorTips);\n            reject && reject(errorTips);\n          };\n        }\n\n        if (Promise) {\n          return finallyCallback && new Promise(function (resolve, reject) {\n            // 拓展 args\n            args = args.concat([resolve, reject]);\n            finallyCallback.apply(_this, args);\n          });\n        }\n\n        return finallyCallback && finallyCallback.apply(_this, args);\n      };\n    };\n    /**\n     * 析构函数\n     */\n\n\n    Proxy.prototype.dispose = function dispose() {\n      this.api = null;\n      this.callback = null;\n    };\n\n    hybridJs.Proxy = Proxy;\n  }\n  /**\n   * h5和原生交互，jsbridge核心代码\n   * 依赖于showError，globalError，os\n   */\n\n\n  function jsbridgeMixin(hybrid) {\n    var hybridJs = hybrid; // 必须要有一个全局的JSBridge，否则原生和H5无法通信\n    // 定义每次重新生成一个JSBridge\n\n    window.JSBridge = {};\n    var JSBridge = window.JSBridge; // 声明依赖\n\n    var showError = hybridJs.showError;\n    var globalError = hybridJs.globalError;\n    var os = hybridJs.os;\n    hybridJs.JSBridge = JSBridge; // jsbridge协议定义的名称\n\n    var CUSTOM_PROTOCOL_SCHEME = 'EpointJSBridge'; // 本地注册的方法集合,原生只能调用本地注册的方法,否则会提示错误\n\n    var messageHandlers = {}; // 短期回调函数集合\n    // 在原生调用完对应的方法后,会执行对应的回调函数id，并删除\n\n    var responseCallbacks = {}; // 长期存在的回调，调用后不会删除\n\n    var responseCallbacksLongTerm = {}; // 唯一id,用来确保长期回调的唯一性，初始化为最大值\n\n    var uniqueLongCallbackId = 65536; // 要排除掉的端口号\n\n    var excludePort = [8193, 8194, 8195];\n    /**\n     * 获取短期回调id，内部要避免和长期回调的冲突\n     * @return {Number} 返回一个随机的短期回调id\n     */\n\n    function getCallbackId() {\n      var exclude = function exclude(port) {\n        if (excludePort.indexOf(port) !== -1) {\n          return exclude(Math.floor(Math.random() * uniqueLongCallbackId));\n        }\n\n        return port;\n      }; // 确保每次都不会和长期id相同\n\n\n      return exclude(Math.floor(Math.random() * uniqueLongCallbackId));\n    }\n    /**\n     * 将JSON参数转为字符串\n     * @param {Object} data 对应的json对象\n     * @return {String} 转为字符串后的结果\n     */\n\n\n    function getParam(data) {\n      if (typeof data !== 'string') {\n        return JSON.stringify(data);\n      }\n\n      return data;\n    }\n    /**\n     * 获取最终的url scheme\n     * @param {String} proto 协议头，一般不同模块会有不同的协议头\n     * @param {Object} message 兼容android中的做法\n     * android中由于原生不能获取JS函数的返回值,所以得通过协议传输\n     * @return {String} 返回拼接后的uri\n     */\n\n\n    function getUri(proto, message) {\n      var uri = CUSTOM_PROTOCOL_SCHEME + '://' + proto; // 回调id作为端口存在\n\n      var callbackId = void 0;\n      var method = void 0;\n      var params = void 0;\n\n      if (message.callbackId) {\n        // 必须有回调id才能生成一个scheme\n        // 这种情况是H5主动调用native时\n        callbackId = message.callbackId;\n        method = message.handlerName;\n        params = message.data;\n      } // 参数转为字符串\n\n\n      params = encodeURIComponent(getParam(params)); // uri 补充,需要编码，防止非法字符\n\n      uri += ':' + callbackId + '/' + method + '?' + params;\n      return uri;\n    }\n    /**\n     * JS调用原生方法前,会先send到这里进行处理\n     * @param {String} proto 这个属于协议头的一部分\n     * @param {JSON} message 调用的方法详情,包括方法名,参数\n     * @param {Object} responseCallback 调用完方法后的回调,或者长期回调的id\n     */\n\n\n    function doSend(proto, message, responseCallback) {\n      var newMessage = message;\n\n      if (typeof responseCallback === 'function') {\n        // 如果传入的回调时函数，需要给它生成id\n        // 取到一个唯一的callbackid\n        var callbackId = getCallbackId(); // 回调函数添加到短期集合中\n\n        responseCallbacks[callbackId] = responseCallback; // 方法的详情添加回调函数的关键标识\n\n        newMessage.callbackId = callbackId;\n      } else {\n        // 如果传入时已经是id，代表已经在回调池中了，直接使用即可\n        newMessage.callbackId = responseCallback;\n      } // 获取 触发方法的url scheme\n\n\n      var uri = getUri(proto, newMessage);\n\n      if (os.ejs) {\n        // 依赖于os判断\n        if (os.ios) {\n          // ios采用\n          window.webkit.messageHandlers.WKWebViewJavascriptBridge.postMessage(uri);\n        } else {\n          window.top.prompt(uri, '');\n        }\n      } else {\n        // 浏览器\n        warn(\"\\u6D4F\\u89C8\\u5668\\u4E2Djsbridge\\u65E0\\u6548,\\u5BF9\\u5E94scheme:\" + uri);\n      }\n    }\n    /**\n     * 注册本地JS方法通过JSBridge给原生调用\n     * 我们规定,原生必须通过JSBridge来调用H5的方法\n     * 注意,这里一般对本地函数有一些要求,要求第一个参数是data,第二个参数是callback\n     * @param {String} handlerName 方法名\n     * @param {Function} handler 对应的方法\n     */\n\n\n    JSBridge.registerHandler = function registerHandler(handlerName, handler) {\n      messageHandlers[handlerName] = handler;\n    };\n    /**\n     * 注册长期回调到本地\n     * @param {String} callbackId 回调id\n     * @param {Function} callback 对应回调函数\n     */\n\n\n    JSBridge.registerLongCallback = function registerLongCallback(callbackId, callback) {\n      responseCallbacksLongTerm[callbackId] = callback;\n    };\n    /**\n     * 获得本地的长期回调，每一次都是一个唯一的值\n     * @retrurn 返回对应的回调id\n     * @return {Number} 返回长期回调id\n     */\n\n\n    JSBridge.getLongCallbackId = function getLongCallbackId() {\n      uniqueLongCallbackId -= 1;\n      return uniqueLongCallbackId;\n    };\n    /**\n     * 调用原生开放的方法\n     * @param {String} proto 这个属于协议头的一部分\n     * @param {String} handlerName 方法名\n     * @param {JSON} data 参数\n     * @param {Object} callback 回调函数或者是长期的回调id\n     */\n\n\n    JSBridge.callHandler = function callHandler(proto, handlerName, data, callback) {\n      doSend(proto, {\n        handlerName: handlerName,\n        data: data\n      }, callback);\n    };\n    /**\n     * 原生调用H5页面注册的方法,或者调用回调方法\n     * @param {String} messageJSON 对应的方法的详情,需要手动转为json\n     */\n\n\n    JSBridge._handleMessageFromNative = function _handleMessageFromNative(messageJSON) {\n      /**\n       * 处理原生过来的方法\n       */\n      function doDispatchMessageFromNative() {\n        var message = void 0;\n\n        try {\n          if (typeof messageJSON === 'string') {\n            message = decodeURIComponent(messageJSON);\n            message = JSON.parse(message);\n          } else {\n            message = messageJSON;\n          }\n        } catch (e) {\n          showError(globalError.ERROR_TYPE_NATIVECALL.code, globalError.ERROR_TYPE_NATIVECALL.msg);\n          return;\n        } // 回调函数\n\n\n        var responseId = message.responseId;\n        var responseData = message.responseData;\n        var responseCallback = void 0;\n\n        if (responseId) {\n          // 这里规定,原生执行方法完毕后准备通知h5执行回调时,回调函数id是responseId\n          responseCallback = responseCallbacks[responseId]; // 默认先短期再长期\n\n          responseCallback = responseCallback || responseCallbacksLongTerm[responseId]; // 执行本地的回调函数\n\n          responseCallback && responseCallback(responseData);\n          delete responseCallbacks[responseId];\n        } else {\n          /**\n           * 否则,代表原生主动执行h5本地的函数\n           * 从本地注册的函数中获取\n           */\n          var handler = messageHandlers[message.handlerName];\n          var data = message.data; // 执行本地函数,按照要求传入数据和回调\n\n          handler && handler(data);\n        }\n      } // 使用异步\n\n\n      setTimeout(doDispatchMessageFromNative);\n    };\n  }\n  /**\n   * 内部触发jsbridge的方式，作为一个工具类提供\n   */\n\n\n  function generateJSBridgeTrigger(JSBridge) {\n    /**\n     * 有三大类型，短期回调，延时回调，长期回调，其中长期回调中又有一个event比较特殊\n     * @param {JSON} options 配置参数，包括\n     * handlerName 方法名\n     * data 额外参数\n     * isLongCb 是否是长期回调，如果是，则会生成一个长期回调id，以长期回调的形式存在\n     * proto 对应方法的模块名\n     * 其它 代表相应的头部\n     * @param {Function} resolve promise中成功回调函数\n     * @param {Function} reject promise中失败回调函数\n     */\n    return function callJsBridge(options, resolve, reject) {\n      var success = options.success;\n      var error = options.error;\n      var dataFilter = options.dataFilter;\n      var proto = options.proto;\n      var handlerName = options.handlerName;\n      var isLongCb = options.isLongCb;\n      var isEvent = options.isEvent;\n      var data = options.data; // 统一的回调处理\n\n      var cbFunc = function cbFunc(res) {\n        if (res.code === 0) {\n          error && error(res); // 长期回调不走promise\n\n          !isLongCb && reject && reject(res);\n        } else {\n          var finalRes = res;\n\n          if (dataFilter) {\n            finalRes = dataFilter(finalRes);\n          } // 提取出result\n\n\n          success && success(finalRes.result);\n          !isLongCb && resolve && resolve(finalRes.result);\n        }\n      };\n\n      if (isLongCb) {\n        /**\n         * 长期回调的做法，需要注册一个长期回调id,每一个方法都有一个固定的长期回调id\n         * 短期回调的做法(短期回调执行一次后会自动销毁)\n         * 但长期回调不会销毁，因此可以持续触发，例如下拉刷新\n         * 长期回调id通过函数自动生成，每次会获取一个唯一的id\n         */\n        var longCbId = JSBridge.getLongCallbackId();\n\n        if (isEvent) {\n          // 如果是event，data里需要增加一个参数\n          data.port = longCbId;\n        }\n\n        JSBridge.registerLongCallback(longCbId, cbFunc); // 传入的是id\n\n        JSBridge.callHandler(proto, handlerName, data, longCbId); // 长期回调默认就成功了，这是兼容的情况，防止有人误用\n\n        resolve && resolve();\n      } else {\n        // 短期回调直接使用方法\n        JSBridge.callHandler(proto, handlerName, data, cbFunc);\n      }\n    };\n  }\n  /**\n   * 如果api没有runcode，应该有一个默认的实现\n   */\n\n\n  function callinnerMixin(hybrid) {\n    var hybridJs = hybrid;\n    var os = hybridJs.os;\n    var JSBridge = hybridJs.JSBridge;\n    var callJsBridge = generateJSBridgeTrigger(JSBridge);\n    /**\n     * 专门供API内部调用的，this指针被指向了proxy对象，方便处理\n     * @param {Object} options 配置参数\n     * @param {Function} resolve promise的成功回调\n     * @param {Function} reject promise的失败回调\n     */\n\n    function callInner(options, resolve, reject) {\n      var data = extend({}, options); // 纯数据不需要回调\n\n      data.success = undefined;\n      data.error = undefined;\n      data.dataFilter = undefined;\n\n      if (os.ejs) {\n        // 默认ejs环境才触发jsbridge\n        callJsBridge({\n          handlerName: this.api.namespace,\n          data: data,\n          proto: this.api.moduleName,\n          success: options.success,\n          error: options.error,\n          dataFilter: options.dataFilter,\n          isLongCb: this.api.isLongCb,\n          isEvent: this.api.isEvent\n        }, resolve, reject);\n      }\n    }\n\n    hybridJs.callInner = callInner;\n  }\n  /**\n   * 定义API的添加\n   * 必须按照特定方法添加API才能正常的代理\n   * 依赖于一些基本库\n   * os\n   * Proxy\n   * globalError\n   * showError\n   * callInner\n   */\n\n\n  function defineapiMixin(hybrid) {\n    var hybridJs = hybrid;\n    var Proxy = hybridJs.Proxy;\n    var globalError = hybridJs.globalError;\n    var showError = hybridJs.showError;\n    var os = hybridJs.os;\n    var callInner = hybridJs.callInner;\n    /**\n     * 存放所有的代理 api对象\n     * 每一个命名空间下的每一个os都可以执行\n     * proxyapi[namespace][os]\n     */\n\n    var proxysApis = {};\n    /**\n     * 存放所有的代理 module对象\n     */\n\n    var proxysModules = {};\n    var supportOsArray = ['ejs', 'dd', 'h5'];\n\n    function getCurrProxyApiOs(currOs) {\n      for (var i = 0, len = supportOsArray.length; i < len; i += 1) {\n        if (currOs[supportOsArray[i]]) {\n          return supportOsArray[i];\n        }\n      } // 默认是h5\n\n\n      return 'h5';\n    }\n\n    function getModuleApiParentByNameSpace(module, namespace) {\n      var apiParent = module; // 只取命名空间的父级,如果仅仅是xxx，是没有父级的\n\n      var parentNamespaceArray = /[.]/.test(namespace) ? namespace.replace(/[.][^.]+$/, '').split('.') : [];\n      parentNamespaceArray.forEach(function (item) {\n        apiParent[item] = apiParent[item] || {};\n        apiParent = apiParent[item];\n      });\n      return apiParent;\n    }\n\n    function proxyApiNamespace(apiParent, apiName, finalNameSpace, api) {\n      // 代理API，将apiParent里的apiName代理到Proxy执行\n      Object.defineProperty(apiParent, apiName, {\n        configurable: true,\n        enumerable: true,\n        get: function proxyGetter() {\n          // 确保get得到的函数一定是能执行的\n          var nameSpaceApi = proxysApis[finalNameSpace]; // 得到当前是哪一个环境，获得对应环境下的代理对象\n\n          var proxyObj = nameSpaceApi[getCurrProxyApiOs(os)] || nameSpaceApi.h5;\n\n          if (proxyObj) {\n            /**\n             * 返回代理对象，所以所有的api都会通过这个代理函数\n             * 注意引用问题，如果直接返回原型链式的函数对象，由于是在getter中，里面的this会被改写\n             * 所以需要通过walk后主动返回\n             */\n            return proxyObj.walk();\n          } // 正常情况下走不到，除非预编译的时候在walk里手动抛出\n\n\n          var osErrorTips = api.os ? api.os.join('或') : '\"非法\"';\n          var msg = api.namespace + \"\\u8981\\u6C42\\u7684os\\u73AF\\u5883\\u4E3A:\" + osErrorTips;\n          showError(globalError.ERROR_TYPE_APIOS.code, msg);\n          return noop;\n        },\n        set: function proxySetter() {\n          showError(globalError.ERROR_TYPE_APIMODIFY.code, globalError.ERROR_TYPE_APIMODIFY.msg);\n        }\n      });\n    }\n    /**\n     * 监听模块，防止被篡改\n     * @param {String} moduleName 模块名\n     */\n\n\n    function observeModule(moduleName) {\n      Object.defineProperty(hybridJs, moduleName, {\n        configurable: true,\n        enumerable: true,\n        get: function proxyGetter() {\n          if (!proxysModules[moduleName]) {\n            proxysModules[moduleName] = {};\n          }\n\n          return proxysModules[moduleName];\n        },\n        set: function proxySetter() {\n          showError(globalError.ERROR_TYPE_MODULEMODIFY.code, globalError.ERROR_TYPE_MODULEMODIFY.msg);\n        }\n      });\n    }\n    /**\n     * 在某一个模块下拓展一个API\n     * @param {String} moduleName 模块名\n     * @param {String} apiParam api对象,包含\n     * namespace 命名空间\n     * os 支持的环境\n     * defaultParams 默认参数\n     */\n\n\n    function extendApi(moduleName, apiParam) {\n      if (!apiParam || !apiParam.namespace) {\n        return;\n      }\n\n      if (!hybridJs[moduleName]) {\n        // 如果没有定义模块，监听整个模块，用代理取值，防止重定义\n        // 这样，模块只允许初次定义以及之后的赋值，其它操作都会被内部拒绝\n        observeModule(moduleName);\n      }\n\n      var api = apiParam;\n      var modlue = hybridJs[moduleName];\n      var apiNamespace = api.namespace; // api加上module关键字，方便内部处理\n\n      api.moduleName = moduleName;\n      var apiParent = getModuleApiParentByNameSpace(modlue, apiNamespace); // 最终的命名空间是包含模块的\n\n      var finalNameSpace = moduleName + '.' + api.namespace; // 如果仅仅是xxx，直接取xxx，如果aa.bb，取bb\n\n      var apiName = /[.]/.test(apiNamespace) ? api.namespace.match(/[.][^.]+$/)[0].substr(1) : apiNamespace; // 这里防止触发代理，就不用apiParent[apiName]了，而是用proxysApis[finalNameSpace]\n\n      if (!proxysApis[finalNameSpace]) {\n        // 如果还没有代理这个API的命名空间，代理之，只需要设置一次代理即可\n        proxyApiNamespace(apiParent, apiName, finalNameSpace, api);\n      } // 一个新的API代理，会替换以前API命名空间中对应的内容\n\n\n      var apiRuncode = api.runCode;\n\n      if (!apiRuncode && callInner) {\n        // 如果没有runcode，默认使用callInner\n        apiRuncode = callInner;\n      }\n\n      var newApiProxy = new Proxy(api, apiRuncode);\n      var oldProxyNamespace = proxysApis[finalNameSpace] || {};\n      var oldProxyOsNotUse = {};\n      proxysApis[finalNameSpace] = {};\n      supportOsArray.forEach(function (osTmp) {\n        if (api.os && api.os.indexOf(osTmp) !== -1) {\n          // 如果存在这个os，并且合法，重新定义\n          proxysApis[finalNameSpace][osTmp] = newApiProxy;\n          oldProxyOsNotUse[osTmp] = true;\n        } else if (oldProxyNamespace[osTmp]) {\n          // 否则仍然使用老版本的代理\n          proxysApis[finalNameSpace][osTmp] = oldProxyNamespace[osTmp]; // api本身的os要添加这个环境，便于提示\n\n          api.os && api.os.push(osTmp);\n        }\n      });\n      Object.keys(oldProxyOsNotUse).forEach(function (notUseOs) {\n        // 析构不用的代理\n        oldProxyNamespace[notUseOs] && oldProxyNamespace[notUseOs].dispose();\n      });\n    }\n    /**\n     * 拓展整个对象的模块\n     * @param {String} moduleName 模块名\n     * @param {Array} apis 对应的api数组\n     */\n\n\n    function extendModule(moduleName, apis) {\n      if (!apis || !Array.isArray(apis)) {\n        return;\n      }\n\n      if (!hybridJs[moduleName]) {\n        // 如果没有定义模块，监听整个模块，用代理取值，防止重定义\n        // 这样，模块只允许初次定义以及之后的赋值，其它操作都会被内部拒绝\n        observeModule(moduleName);\n      }\n\n      for (var i = 0, len = apis.length; i < len; i += 1) {\n        extendApi(moduleName, apis[i]);\n      }\n    }\n\n    hybridJs.extendModule = extendModule;\n    hybridJs.extendApi = extendApi;\n  }\n  /**\n   * 定义如何调用一个API\n   * 一般指调用原生环境下的API\n   * 依赖于Promise,calljsbridgeMixin\n   */\n\n\n  function callnativeapiMixin(hybrid) {\n    var hybridJs = hybrid;\n    var JSBridge = hybridJs.JSBridge;\n    var callJsBridge = generateJSBridgeTrigger(JSBridge);\n    /**\n     * 调用自定义API\n     * @param {Object} options 配置参数\n     * @return {Object} 返回一个Promise对象，如果没有Promise环境，直接返回运行结果\n     */\n\n    function callApi(options) {\n      // 实时获取promise\n      var Promise = hybridJs.getPromise();\n      var finalOptions = options || {};\n\n      var callback = function callback(resolve, reject) {\n        callJsBridge({\n          handlerName: finalOptions.name,\n          proto: finalOptions.mudule,\n          data: finalOptions.data || {},\n          success: finalOptions.success,\n          error: finalOptions.error,\n          isLongCb: finalOptions.isLongCb,\n          isEvent: finalOptions.isEvent\n        }, resolve, reject);\n      };\n\n      return Promise && new Promise(callback) || callback();\n    }\n\n    hybridJs.callApi = callApi;\n    hybridJs.callNativeApi = callApi;\n  }\n  /**\n   * 初始化给配置全局函数\n   */\n\n\n  function initMixin(hybrid) {\n    var hybridJs = hybrid;\n    var globalError = hybridJs.globalError;\n    var showError = hybridJs.showError;\n    var JSBridge = hybridJs.JSBridge;\n    /**\n     * 几个全局变量 用来控制全局的config与ready逻辑\n     * 默认ready是false的\n     */\n\n    var readyFunc = void 0;\n    var isAllowReady = false;\n    var isConfig = false;\n    /**\n     * 检查环境是否合法，包括\n     * 检测是否有检测版本号，如果不是，给出错误提示\n     * 是否版本号小于容器版本号，如果小于，给予升级提示\n     */\n\n    function checkEnvAndPrompt() {\n      if (!hybridJs.runtime || !hybridJs.runtime.getEjsVersion) {\n        showError(globalError.ERROR_TYPE_VERSIONNOTSUPPORT.code, globalError.ERROR_TYPE_VERSIONNOTSUPPORT.msg);\n      } else {\n        hybridJs.runtime.getEjsVersion({\n          success: function success(result) {\n            /**\n             * 版本可以有差异\n            const version = `${result.version} `;\n             if (compareVersion(hybridJs.version, version) < 0) {\n                showError(\n                    globalError.ERROR_TYPE_VERSIONNEEDUPGRADE.code,\n                    globalError.ERROR_TYPE_VERSIONNEEDUPGRADE.msg);\n            }\n             */\n            // 记录原生容器的版本号\n            hybridJs.nativeVersion = result.version;\n          },\n          error: function error() {\n            showError(globalError.ERROR_TYPE_INITVERSIONERROR.code, globalError.ERROR_TYPE_INITVERSIONERROR.msg);\n          }\n        });\n      }\n    }\n    /**\n     * 页面初始化时必须要这个config函数\n     * 必须先声明ready，然后再config\n     * @param {Object} params\n     * config的jsApiList主要是同来通知给原生进行注册的\n     * 所以这个接口到时候需要向原生容器请求的\n     */\n\n\n    hybridJs.config = function config(params) {\n      if (hybridJs.os.dd && window.dd) {\n        dd.config(params);\n      } else if (isConfig) {\n        showError(globalError.ERROR_TYPE_CONFIGMODIFY.code, globalError.ERROR_TYPE_CONFIGMODIFY.msg);\n      } else {\n        isConfig = true;\n\n        var _success = function _success() {\n          // 如果这时候有ready回调\n          if (readyFunc) {\n            log('ready!');\n            readyFunc();\n          } else {\n            // 允许ready直接执行\n            isAllowReady = true;\n          }\n        };\n\n        if (hybridJs.os.ejs) {\n          // 暂时检查环境默认就进行，因为框架默认注册了基本api的，并且这样2.也可以给予相应提示\n          checkEnvAndPrompt();\n          hybridJs.event.config(extend({\n            success: function success() {\n              _success();\n            },\n            error: function error(_error) {\n              var tips = JSON.stringify(_error);\n              showError(globalError.ERROR_TYPE_CONFIGERROR.code, tips);\n            }\n          }, params));\n        } else {\n          _success();\n        }\n      }\n    };\n    /**\n     * 初始化完毕，并且config验证完毕后会触发这个回调\n     * 注意，只有config了，才会触发ready，否则无法触发\n     * ready只会触发一次，所以如果同时设置两个，第二个ready回调会无效\n     * @param {Function} callback 回调函数\n     */\n\n\n    hybridJs.ready = function ready(callback) {\n      if (hybridJs.os.dd && window.dd) {\n        dd.ready(callback);\n      } else if (!readyFunc) {\n        readyFunc = callback; // 如果config先进行，然后才进行ready,这时候恰好又isAllowReady，代表ready可以直接自动执行\n\n        if (isAllowReady) {\n          log('ready!');\n          isAllowReady = false;\n          readyFunc();\n        }\n      } else {\n        showError(globalError.ERROR_TYPE_READYMODIFY.code, globalError.ERROR_TYPE_READYMODIFY.msg);\n      }\n    };\n    /**\n     * 注册接收原生的错误信息\n     */\n\n\n    JSBridge.registerHandler('handleError', function (data) {\n      showError(globalError.ERROR_TYPE_NATIVE.code, JSON.stringify(data));\n    });\n  }\n\n  function innerUtilMixin(hybrid) {\n    var hybridJs = hybrid;\n    var innerUtil = {};\n    hybridJs.innerUtil = innerUtil;\n    /**\n     * 将参数兼容字符串形式，返回新的args\n     * 正常应该是 object, resolve, reject\n     * 兼容的字符串可能是 key1, (key2, key3,) ..., resolve, reject\n     * @param {Object} args 原始的参数\n     * @param {Object} rest 剩余的参数，相当于从arguments1开始算起\n     * @return {Object} 返回标准的参数\n     */\n\n    function compatibleStringParamsToObject(args) {\n      var _this = this;\n\n      var newArgs = args;\n\n      if (!innerUtil.isObject(newArgs[0])) {\n        var options = {};\n        var isPromise = !!hybridJs.getPromise();\n        var len = newArgs.length;\n        var paramsLen = isPromise ? len - 2 : len; // 填充字符串key，排除最后的resolve与reject\n\n        for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          rest[_key - 1] = arguments[_key];\n        }\n\n        for (var i = 0; i < paramsLen; i += 1) {\n          // 注意映射关系，rest[0]相当于以前的arguments[1]\n          if (rest[i] !== undefined) {\n            options[rest[i]] = newArgs[i];\n          }\n        } // 分别为options，resolve，reject\n\n\n        newArgs[0] = options;\n\n        if (isPromise) {\n          newArgs[1] = newArgs[len - 2];\n          newArgs[2] = newArgs[len - 1];\n        } else {\n          // 去除普通参数对resolve与reject的影响\n          newArgs[1] = undefined;\n          newArgs[2] = undefined;\n        }\n      } // 默认参数的处理，因为刚兼容字符串后是没有默认参数的\n\n\n      if (this.api && this.api.defaultParams && newArgs[0] instanceof Object) {\n        Object.keys(this.api.defaultParams).forEach(function (item) {\n          if (newArgs[0][item] === undefined) {\n            newArgs[0][item] = _this.api.defaultParams[item];\n          }\n        });\n      } // 否则已经是标准的参数形式，直接返回\n\n\n      return newArgs;\n    }\n    /**\n     * 限制按钮个数，只选其中num个\n     * @param {Array} arr 参数数组\n     * @param {Number} maximum 允许最大个数\n     * @returns {Array} 返回正确的数组\n     */\n\n\n    function eclipseButtonsNumber(arr, maximum) {\n      var result = arr;\n\n      if (result && Array.isArray(result)) {\n        var len = result.length;\n\n        if (len > maximum) {\n          var difference = len - (len - maximum);\n          result.length = difference;\n        }\n      }\n\n      return result;\n    }\n\n    innerUtil.extend = extend;\n    innerUtil.isObject = isObject;\n    innerUtil.getFullPath = getFullPath;\n    innerUtil.getFullUrlByParams = getFullUrlByParams;\n    innerUtil.eclipseText = eclipseText;\n    innerUtil.compatibleStringParamsToObject = compatibleStringParamsToObject;\n    innerUtil.eclipseButtonsNumber = eclipseButtonsNumber;\n    innerUtil.getBase64NotUrl = getBase64NotUrl;\n  }\n\n  function mixin(hybrid) {\n    var hybridJs = hybrid;\n    osMixin(hybridJs);\n    promiseMixin(hybridJs);\n    errorMixin(hybridJs); // 不依赖于promise，但是是否有Promise决定返回promise对象还是普通函数, 依赖于globalError\n\n    proxyMixin(hybridJs); // 依赖于showError，globalError，os\n\n    jsbridgeMixin(hybridJs); // api没有runcode时的默认实现，依赖于jsbridge与os\n\n    callinnerMixin(hybridJs); // 依赖于os，Proxy，globalError，showError，以及callInner\n\n    defineapiMixin(hybridJs); // 依赖于JSBridge，Promise,sbridge\n\n    callnativeapiMixin(hybridJs); // init依赖与基础库以及部分原生的API\n\n    initMixin(hybridJs); // 给API快速使用的内部工具集\n\n    innerUtilMixin(hybridJs);\n  }\n\n  var hybridJs = {};\n  mixin(hybridJs);\n  hybridJs.version = '3.2.6d';\n  return hybridJs;\n});",null]}