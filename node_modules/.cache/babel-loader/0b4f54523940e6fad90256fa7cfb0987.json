{"remainingRequest":"/Users/gujiahao/Documents/work/github/artweb/node_modules/thread-loader/dist/cjs.js!/Users/gujiahao/Documents/work/github/artweb/node_modules/babel-loader/lib/index.js!/Users/gujiahao/Documents/work/github/artweb/node_modules/@vue/cli-plugin-eslint/node_modules/eslint-loader/index.js??ref--13-0!/Users/gujiahao/Documents/work/github/artweb/public/ejs/v2/epoint.moapi.v2.js","dependencies":[{"path":"/Users/gujiahao/Documents/work/github/artweb/public/ejs/v2/epoint.moapi.v2.js","mtime":1588230106456},{"path":"/Users/gujiahao/Documents/work/github/artweb/node_modules/cache-loader/dist/cjs.js","mtime":1579587180818},{"path":"/Users/gujiahao/Documents/work/github/artweb/node_modules/thread-loader/dist/cjs.js","mtime":1579587183081},{"path":"/Users/gujiahao/Documents/work/github/artweb/node_modules/babel-loader/lib/index.js","mtime":1585810045725},{"path":"/Users/gujiahao/Documents/work/github/artweb/node_modules/@vue/cli-plugin-eslint/node_modules/eslint-loader/index.js","mtime":1579587173378}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es6.regexp.match\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.function.name\";\nimport _typeof from \"/Users/gujiahao/Documents/work/github/artweb/node_modules/@babel/runtime-corejs2/helpers/esm/typeof\";\n\n/**\n * 作者: guotq\n * 创建时间: 2016/12/06\n * 版本: [1.0, 2017/08/07 ]\n * 版权: 江苏国泰新点软件有限公司\n * 描述: ejs 2.1系列版本，基于JSBridge技术，异步与原生容器交互\n * 最新更新版本为2.1.9\n * 最新修改，支持相对路径的打开，configvalue支持h5下的回调\n */\n(function (global, factory) {\n  \"use strict\";\n\n  var moduleExports = factory(global);\n\n  if (typeof module !== 'undefined' && (typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === 'object') {\n    module.exports = moduleExports;\n  } else if (typeof define === 'function' && (define.amd || define.cmd)) {\n    define(function () {\n      return moduleExports;\n    });\n  }\n})(typeof window !== 'undefined' ? window : global, function (global) {\n  \"use strict\"; //实际的逻辑代码\n\n  var isEmptyObject = function isEmptyObject(e) {\n    for (var t in e) {\n      if (window.Config && window.Config.ejsVer != undefined && window.Config.ejsVer != 2) {\n        // 如果存在框架配置 ejs版本不为2.0 也重新生成\n        return 1;\n      }\n\n      return 0;\n    }\n\n    return 1;\n  }; //实际的逻辑代码-确保只会被执行一遍\n\n\n  if (!isEmptyObject(global.ejs)) {\n    //如果已经不是空对象，就不再次运行\n    return global.ejs;\n  } //返回全局变量返回值，便于模块化时引用，也同时声明全局对象\n\n\n  return function (exports, isLocal) {\n    /******************通用代码**********************/\n    (function () {\n      /**\n       * extend(simple)\n       * @param {type} deep 是否递归合并\n       * @param {type} target 最终返回的就是target\n       * @param {type} source 从左到又，优先级依次提高，最右侧的是最后覆盖的\n       * @returns {unresolved}\n       */\n      exports.extend = function () {\n        // from jquery2\n        var options,\n            name,\n            src,\n            copy,\n            copyIsArray,\n            clone,\n            target = arguments[0] || {},\n            i = 1,\n            length = arguments.length,\n            deep = false;\n\n        if (typeof target === \"boolean\") {\n          deep = target;\n          target = arguments[i] || {};\n          i++;\n        }\n\n        if (_typeof(target) !== \"object\" && !exports.isFunction(target)) {\n          target = {};\n        }\n\n        if (i === length) {\n          target = this;\n          i--;\n        }\n\n        for (; i < length; i++) {\n          if ((options = arguments[i]) != null) {\n            for (name in options) {\n              src = target[name];\n              copy = options[name];\n\n              if (target === copy) {\n                continue;\n              }\n\n              if (deep && copy && (exports.isPlainObject(copy) || (copyIsArray = exports.isArray(copy)))) {\n                if (copyIsArray) {\n                  copyIsArray = false;\n                  clone = src && exports.isArray(src) ? src : [];\n                } else {\n                  clone = src && exports.isPlainObject(src) ? src : {};\n                }\n\n                target[name] = exports.extend(deep, clone, copy);\n              } else if (copy !== undefined) {\n                target[name] = copy;\n              }\n            }\n          }\n        }\n\n        return target;\n      };\n      /**\n       *  isFunction\n       */\n\n\n      exports.noop = function () {},\n      /**\n       *  isFunction\n       */\n      exports.isFunction = function (value) {\n        return exports.type(value) === \"function\";\n      };\n      /**\n       *  isPlainObject\n       */\n\n      exports.isPlainObject = function (obj) {\n        return exports.isObject(obj) && !exports.isWindow(obj) && Object.getPrototypeOf(obj) === Object.prototype;\n      };\n\n      exports.isArray = Array.isArray || function (object) {\n        return object instanceof Array;\n      };\n      /**\n       *  isWindow(需考虑obj为undefined的情况)\n       */\n\n\n      exports.isWindow = function (obj) {\n        return obj != null && obj === obj.window;\n      };\n      /**\n       *  isObject\n       */\n\n\n      exports.isObject = function (obj) {\n        return exports.type(obj) === \"object\";\n      };\n\n      exports.type = function (obj) {\n        return obj == null ? String(obj) : class2type[{}.toString.call(obj)] || \"object\";\n      };\n      /**\n       * @description each遍历操作\n       * @param {type} elements\n       * @param {type} callback\n       * @returns {global}\n       */\n\n\n      exports.each = function (elements, callback, hasOwnProperty) {\n        if (!elements) {\n          return this;\n        }\n\n        if (typeof elements.length === 'number') {\n          [].every.call(elements, function (el, idx) {\n            return callback.call(el, idx, el) !== false;\n          });\n        } else {\n          for (var key in elements) {\n            if (hasOwnProperty) {\n              if (elements.hasOwnProperty(key)) {\n                if (callback.call(elements[key], key, elements[key]) === false) return elements;\n              }\n            } else {\n              if (callback.call(elements[key], key, elements[key]) === false) return elements;\n            }\n          }\n        }\n\n        return this;\n      };\n\n      var class2type = {};\n      exports.each(['Boolean', 'Number', 'String', 'Function', 'Array', 'Date', 'RegExp', 'Object', 'Error'], function (i, name) {\n        class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\n      });\n\n      (function () {\n        function detect(ua) {\n          this.os = {};\n          this.os.name = 'browser';\n          var funcs = [function () {\n            //android\n            var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n\n            if (android) {\n              this.os.android = true;\n              this.os.version = android[2];\n              this.os.isBadAndroid = !/Chrome\\/\\d/.test(window.navigator.appVersion);\n              this.os.name += '_' + 'Android';\n              this.os.name += '_' + 'mobile';\n            }\n\n            return this.os.android === true;\n          }, function () {\n            //ios\n            var iphone = ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n\n            if (iphone) {\n              //iphone\n              this.os.ios = this.os.iphone = true;\n              this.os.version = iphone[2].replace(/_/g, '.');\n              this.os.name += '_' + 'iphone';\n              this.os.name += '_' + 'mobile';\n            } else {\n              var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n\n              if (ipad) {\n                //ipad\n                this.os.ios = this.os.ipad = true;\n                this.os.version = ipad[2].replace(/_/g, '.');\n                this.os.name += '_' + 'iOS';\n                this.os.name += '_' + 'mobile';\n              }\n            }\n\n            return this.os.ios === true;\n          }];\n          [].every.call(funcs, function (func) {\n            return !func.call(exports);\n          });\n        }\n\n        detect.call(exports, navigator.userAgent);\n      })();\n      /**\n       * @description 判断os系统 ,判断是否是ejs\n       * ejs.os\n       * @param {type} \n       * @returns {undefined}\n       */\n\n\n      (function () {\n        function detect(ua) {\n          this.os = this.os || {}; //比如 EpointEJS/6.1.1  也可以/(EpointEJS)\\/([\\d\\.]+)/i\n\n          var ejs = ua.match(/EpointEJS/i); //TODO ejs\n\n          if (ejs) {\n            this.os.ejs = true;\n            this.os.name += '_' + 'ejs';\n          } //阿里的钉钉 DingTalk/3.0.0 \n\n\n          var dd = ua.match(/DingTalk/i); //TODO dingding\n\n          if (dd) {\n            this.os.dd = true;\n            this.os.name += '_' + 'dd';\n          } // 如果ejs和钉钉都不是，则默认为h5\n\n\n          if (!ejs && !dd) {\n            this.os.h5 = true;\n            this.os.name += '_' + 'h5';\n          }\n        }\n\n        detect.call(exports, navigator.userAgent);\n      })();\n    })();\n    /******************ejs核心代码**********************/\n    //最外层的ejs api名称\n\n\n    var EJS_API = 'epoint_bridge'; //全局错误回调\n\n    var globalError; // 错误池子，页面加载时候的错误先存储\n\n    var errorPool = [];\n    ejs.EJS_API = EJS_API; //默认的自定义api的名\n\n    var EJS_API_CUSTOM = 'custom_epoint_bridge';\n    ejs.EJS_API_CUSTOM = EJS_API_CUSTOM; //长期存在的回调\n\n    var responseCallbacksLongTerm = {};\n\n    (function () {\n      var hasOwnProperty = Object.prototype.hasOwnProperty;\n      window.JSBridge = window.top.JSBridge || {}; //jsbridge协议定义的名称\n\n      var CUSTOM_PROTOCOL_SCHEME = 'EpointJSBridge'; //ios中进行url scheme传值的iframe,用top,否则如果在iframe中,无法正常触发\n\n      var messagingIframe = window.top.document.createElement('iframe');\n      messagingIframe.style.display = 'none';\n\n      if (ejs.os.ejs && ejs.os.ios) {\n        messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://__BRIDGE_LOADED__';\n      }\n\n      document.documentElement.appendChild(messagingIframe); //定义的回调函数集合,在原生调用完对应的方法后,会执行对应的回调函数id\n\n      var responseCallbacks = {}; //唯一id,用来确保每一个回调函数的唯一性\n\n      var uniqueId = 1; //本地注册的方法集合,原生只能调用本地注册的方法,否则会提示错误\n\n      var messageHandlers = {}; //当原生调用H5注册的方法时,通过回调来调用(也就是变为了异步执行,加强安全性)\n\n      var dispatchMessagesWithTimeoutSafety = true; //本地运行中的方法队列\n\n      var sendMessageQueue = []; //实际暴露给原生调用的对象\n\n      var Inner = {\n        /**\n         * @description 注册本地JS方法通过JSBridge给原生调用\n         * 我们规定,原生必须通过JSBridge来调用H5的方法\n         * 注意,这里一般对本地函数有一些要求,要求第一个参数是data,第二个参数是callback\n         * @param {String} handlerName 方法名\n         * @param {Function} handler 对应的方法\n         */\n        registerHandler: function registerHandler(handlerName, handler) {\n          messageHandlers[handlerName] = handler;\n        },\n\n        /**\n         * @description 注册长期回调到本地\n         * @param {String} callbackId 回调id\n         * @param {Function} callback 对应回调函数\n         */\n        registerLongCallback: function registerLongCallback(callbackId, callback) {\n          responseCallbacksLongTerm[callbackId] = callback;\n        },\n\n        /**\n         * @description 调用原生开放的方法\n         * @param {String} obj 这个属于协议头的一部分\n         * @param {String} handlerName 方法名\n         * @param {JSON} data 参数\n         * @param {Function||String} callback 回调函数或者是长期的回调id\n         */\n        callHandler: function callHandler(obj, handlerName, data, callback) {\n          //如果没有 data\n          if (arguments.length == 3 && typeof data == 'function') {\n            callback = data;\n            data = null;\n          }\n\n          _doSend(obj, {\n            handlerName: handlerName,\n            data: data\n          }, callback);\n        },\n\n        /**\n         * iOS专用\n         * @description 当本地调用了callHandler之后,实际是调用了通用的scheme,通知原生\n         * 然后原生通过调用这个方法来获知当前正在调用的方法队列\n         */\n        _fetchQueue: function _fetchQueue() {\n          var messageQueueString = JSON.stringify(sendMessageQueue);\n          sendMessageQueue = [];\n          return messageQueueString;\n        },\n\n        /**\n         * @description 原生调用H5页面注册的方法,或者调用回调方法\n         * @param {String} messageJSON 对应的方法的详情,需要手动转为json\n         */\n        _handleMessageFromNative: function _handleMessageFromNative(messageJSON) {\n          if (dispatchMessagesWithTimeoutSafety) {\n            setTimeout(_doDispatchMessageFromNative);\n          } else {\n            _doDispatchMessageFromNative();\n          }\n          /**\n           * @description 处理原生过来的方法\n           */\n\n\n          function _doDispatchMessageFromNative() {\n            var message;\n\n            try {\n              if (typeof messageJSON === 'string') {\n                message = JSON.parse(messageJSON);\n              } else {\n                message = messageJSON;\n              }\n            } catch (e) {\n              //TODO handle the exception\n              console.error(\"原生调用H5方法出错,传入参数错误\");\n              return;\n            } //回调函数\n\n\n            var responseCallback;\n\n            if (message.responseId) {\n              //这里规定,原生执行方法完毕后准备通知h5执行回调时,回调函数id是responseId\n              responseCallback = responseCallbacks[message.responseId];\n              responseCallback = responseCallback || responseCallbacksLongTerm[message.responseId];\n\n              if (!responseCallback) {\n                return;\n              } //执行本地的回调函数\n\n\n              responseCallback && responseCallback(message.responseData);\n              delete responseCallbacks[message.responseId];\n            } else {\n              //否则,代表原生主动执行h5本地的函数\n              if (message.callbackId) {\n                //先判断是否需要本地H5执行回调函数\n                //如果需要本地函数执行回调通知原生,那么在本地注册回调函数,然后再调用原生\n                //回调数据有h5函数执行完毕后传入\n                var callbackResponseId = message.callbackId;\n\n                responseCallback = function responseCallback(responseData) {\n                  //默认是调用EJS api上面的函数\n                  //然后接下来原生知道scheme被调用后主动获取这个信息\n                  //所以原生这时候应该会进行判断,判断对于函数是否成功执行,并接收数据\n                  //这时候通讯完毕(由于h5不会对回调添加回调,所以接下来没有通信了)\n                  _doSend(EJS_API, {\n                    handlerName: message.handlerName,\n                    responseId: callbackResponseId,\n                    responseData: responseData\n                  });\n                };\n              } //从本地注册的函数中获取\n\n\n              var handler = messageHandlers[message.handlerName];\n\n              if (!handler) {//本地没有注册这个函数\n              } else {\n                //执行本地函数,按照要求传入数据和回调\n                handler(message.data, responseCallback);\n              }\n            }\n          }\n        },\n\n        /**\n         * @description 正常来说,在原生调用H5方法是是异步的,调用这个方法后,可以变为同步\n         */\n        disableJavscriptAlertBoxSafetyTimeout: function disableJavscriptAlertBoxSafetyTimeout() {\n          dispatchMessagesWithTimeoutSafety = false;\n        }\n      };\n      /**\n       * @description JS调用原生方法前,会先send到这里进行处理\n       * @param {String} obj 这个属于协议头的一部分\n       * @param {JSON} message 调用的方法详情,包括方法名,参数\n       * @param {Function||String} responseCallback 调用完方法后的回调,或者长期回调的id\n       */\n\n      function _doSend(obj, message, responseCallback) {\n        if (responseCallback && typeof responseCallback === 'function') {\n          //取到一个唯一的callbackid\n          var callbackId = Util.getCallbackId(); //回调函数添加到集合中\n\n          responseCallbacks[callbackId] = responseCallback; //方法的详情添加回调函数的关键标识\n\n          message['callbackId'] = callbackId;\n        } else if (typeof responseCallback === 'string' || typeof responseCallback === 'number') {\n          //长期的回调,传进来的就是id,已经默认在回调池中了\n          message['callbackId'] = responseCallback;\n        } //android中,可以通过onJsPrompt或者截取Url访问都行\n\n\n        if (ejs.os.ios) {\n          //ios中,通过截取客户端url访问\n          //因为ios可以不暴露scheme,而是由原生手动获取\n          //正在调用的方法详情添加进入消息队列中,原生会主动获取\n          sendMessageQueue.push(message);\n        } //获取 触发方法的url scheme\n\n\n        var uri = Util.getUri(obj, message); //android和ios的url scheme调用有所区别\n        //console.log(\"ua:\"+navigator.userAgent);\n        //console.log(\"uri:\"+uri);\n\n        if (ejs.os.ejs) {\n          if (ejs.os.ios) {\n            //ios采用iframe跳转scheme的方法\n            messagingIframe.src = uri; //console.log(\"ios:触发uri:\"+uri);\n          } else {\n            window.top.prompt(uri, \"\");\n          }\n        } else {\n          //浏览器\n          console.error(\"浏览器中ejs无效,scheme:\" + uri);\n        }\n      }\n\n      var Util = {\n        getCallbackId: function getCallbackId() {\n          //return 'cb_' + (uniqueId++) + '_' + new Date().getTime();\n          return Math.floor(Math.random() * (1 << 30)) + '';\n        },\n        //获取url scheme\n        //第二个参数是兼容android中的做法\n        //android中由于原生不能获取JS函数的返回值,所以得通过协议传输\n        getUri: function getUri(obj, message) {\n          var uri = CUSTOM_PROTOCOL_SCHEME + '://' + obj;\n\n          if (!ejs.os.ios) {\n            //回调id作为端口存在\n            var callbackId, method, params;\n\n            if (message.callbackId) {\n              //第一种:h5主动调用原生\n              callbackId = message.callbackId;\n              method = message.handlerName;\n              params = message.data;\n            } else if (message.responseId) {\n              //第二种:原生调用h5后,h5回调\n              //这种情况下需要原生自行分析传过去的port是否是它定义的回调\n              callbackId = message.responseId;\n              method = message.handlerName;\n              params = message.responseData;\n            } //参数转为字符串\n\n\n            params = this.getParam(params); //uri 补充\n\n            uri += ':' + callbackId + '/' + method + '?' + params;\n          }\n\n          return uri;\n        },\n        getParam: function getParam(obj) {\n          if (obj && _typeof(obj) === 'object') {\n            return JSON.stringify(obj);\n          } else {\n            return obj || '';\n          }\n        }\n      };\n\n      for (var key in Inner) {\n        if (!hasOwnProperty.call(JSBridge, key)) {\n          JSBridge[key] = Inner[key];\n        }\n      } // 接收原生的错误信息\n\n\n      JSBridge.registerHandler('handleError', function (data) {\n        if (globalError) {\n          for (var i = 0; i < errorPool.length; i++) {\n            globalError(errorPool[i]);\n          }\n\n          errorPool = [];\n          globalError(data);\n        } else {\n          errorPool.push(data);\n        }\n      });\n    })(); //拓展EJS功能，可以进行插拔式拓展,一般为拓展ejs环境外的使用方法\n    //如兼容h5，兼容钉钉等\n\n\n    (function () {\n      /**\n       * @description 拓展某一个方法\n       * @param {String} moduleName 模块名\n       * @param {String} api 模块下的api名\n       * @param {Function} extendFuc 额外拓展的方法\n       * @param {Boolean} isDisableOld 是否禁用老的api\n       */\n      function extendFuc(moduleName, api, extendFuc, isDisableOld) {\n        isDisableOld = isDisableOld || false;\n\n        if (!ejs[moduleName]) {\n          ejs[moduleName] = {};\n        }\n\n        var module = ejs[moduleName];\n        var old = module[api];\n\n        module[api] = function () {\n          !isDisableOld && old && old.apply(this, arguments);\n          extendFuc.apply(this, arguments);\n        };\n      }\n      /**\n       * @description 拓展整个对象模块\n       * @param {String} moduleName 模块名\n       * @param {Object} obj 对象，对象里包括api名以及方法\n       */\n\n\n      function extendFucObj(moduleName, obj) {\n        for (var item in obj) {\n          extendFuc(moduleName, item, obj[item]);\n        }\n      }\n\n      exports.extendFuc = extendFuc;\n      exports.extendFucObj = extendFucObj;\n    })();\n    /******************ejs api相关**********************/\n    //Android本地资源的路径\n\n\n    var ANDROID_LOCAL = 'file:///android_asset/'; //iOS本地资源的路径\n\n    var IOS_LOCAL = '';\n    /**\n     * @description 得到一个项目的根路径,只适用于混合开发\n     * h5模式下例如:http://id:端口/项目名/\n     * @return {String} 项目的根路径\n     */\n\n    function getProjectBasePath() {\n      var flag = window.ejsForceLocal || isLocal;\n      var basePath = '';\n\n      if (!flag) {\n        //非本地\n        var obj = window.location;\n        var patehName = obj.pathname; //h5\n\n        var contextPath = ''; //这种获取路径的方法有一个要求,那就是所有的html必须在html文件夹中,并且html文件夹必须在项目的根目录\n        //普通浏览器\n\n        contextPath = patehName.substr(0, patehName.lastIndexOf(\"/html\") + 1);\n\n        if (!contextPath || contextPath === '/') {\n          //兼容pages\n          contextPath = patehName.substr(0, patehName.lastIndexOf(\"/pages\") + 1);\n        } //var contextPath = obj.pathname.split(\"/\")[1] + '/';\n\n\n        basePath = obj.protocol + \"//\" + obj.host + (contextPath ? contextPath : '/');\n      } else {\n        //本地\n        if (ejs.os.android) {\n          basePath = ANDROID_LOCAL;\n        } else if (ejs.os.ios) {\n          basePath = IOS_LOCAL;\n        }\n      }\n\n      return basePath;\n    }\n    /**\n     * 将相对路径转为绝对路径 ./ ../ 开头的  为相对路径\n     * 会基于对应调用js的html路径去计算\n     * @param {Object} path\n     */\n\n\n    function changeRelativePathToAbsolute(path) {\n      var obj = window.location,\n          patehName = window.location.pathname; // 匹配相对路径返回父级的个数\n\n      var relatives = path.match(/\\.\\.\\//g);\n      var count = relatives && relatives.length; // 将patehName拆为数组，然后计算当前的父路径，需要去掉相应相对路径的层级\n\n      var pathArray = patehName.split('/');\n      var parentPath = pathArray.slice(0, pathArray.length - (count + 1)).join('/'); // 找到最后的路径， 通过正则 去除 ./ 之前的所有路径\n\n      var finalPath = parentPath + '/' + path.replace(/\\.+\\//g, '');\n      finalPath = obj.protocol + \"//\" + obj.host + finalPath;\n      return finalPath;\n    }\n    /**\n     * @description 得到一个全路径\n     * @param {String} path\n     */\n\n\n    function getFullPath(path) {\n      // 全路径\n      if (/^(http|https|ftp|\\/\\/)/g.test(path)) {\n        return path;\n      } // 是否是相对路径\n\n\n      var isRelative = path.indexOf('./') != -1 || path.indexOf('../') != -1; // 非相对路径，页面路径默认从html目录开始\n\n      path = isRelative ? changeRelativePathToAbsolute(path) : getProjectBasePath() + path;\n      return path;\n    }\n\n    function getFullUrlByParams(url, jsonObj) {\n      url = url || '';\n      url = getFullPath(url); //将jsonObj拼接到url上\n\n      var extrasDataStr = '';\n\n      if (jsonObj) {\n        for (var item in jsonObj) {\n          if (extrasDataStr.indexOf('?') == -1 && url.indexOf('?') == -1) {\n            extrasDataStr += '?';\n          } else {\n            extrasDataStr += '&';\n          }\n\n          extrasDataStr += item + '=' + jsonObj[item];\n        }\n      }\n\n      url = url + extrasDataStr;\n      return url;\n    }\n    /*\n     ***************************EJS API********************************************\n     * 返回参数格式：\n     * {\"code\":1,\"msg\":\"OK\",\"result\":\"{}\"}\n     * code int类型 api调用成功与否 1：成功 0：失败\n     * msg String类型 描述信息\n     * result json类型 返回值\n     * 正常情况下 只会有一个code,又返回值才会有回调result\n     * */\n\n    /**\n     ***Page 模块 ,页面操作\n     */\n\n\n    ejs.page = {\n      /**\n       * @description 打开新页面\n       * 异步\n       * @param {String} url 页面的url\n       * @param {String} title 页面的标题\n       * @param {JSON} jsonObj json参数\n       * @param {JSON} options 额外的配置参数\n       * 包括 requestCode  请求code,startActivityForResult时需要用到,到时候用来进行页面传参\n       * 包括 finishAfterOpen 是否打开下一个页面后关闭关闭当前页面 1为是,其它为否,默认为0\n       * @param {Function} callback 回调函数\n       * @param {Function} error 错误回调\n       */\n      openPage: function openPage(url, title, jsonObj, options, callback, error) {\n        //jsonObj里面的额外参数 viewtitle()\n        jsonObj = jsonObj || {};\n        options = options || {};\n        url = getFullUrlByParams(url, jsonObj); //这时候包括\n\n        options.PAGE_URL = url;\n        options.PAGE_TITLE = title || ''; //一些其它参数就不再定义了,直接传入\n\n        if (ejs.os.ejs || options.isDebug) {\n          //ejs\n          JSBridge.callHandler(EJS_API, 'openPage', {\n            //1为是,其它为否\n            \"finishAfterOpen\": options.finishAfterOpen || '0',\n            //默认为1101\n            'requestCode': options.requestCode || 1101,\n            'data': options\n          }, function (res) {\n            if (res.code == '4') {\n              //默认只有状态为4时才回调\n              callback && callback(res.result, res.msg, res);\n            } else if (res.code == '0') {\n              error && error(res);\n            } else {\n              error && error(res);\n            }\n          });\n        } else {\n          //普通\n          document.location.href = url;\n        }\n      },\n\n      /**\n       * @description 以fragment形式，同时打开多个页面\n       * @param {Array} dataArray 每一个页面的单独参数\n       * url,title,jsonObj,options\n       * @param {JSON} commonOptions 通用配置参数\n       * @param {Function} callback 回调函数\n       */\n      openPageMulti: function openPageMulti(dataArray, commonOptions, callback) {\n        var paramsArray = [];\n\n        for (var i = 0, len = dataArray.length; i < len; i++) {\n          paramsArray[i] = {};\n          paramsArray[i].PAGE_URL = getFullUrlByParams(dataArray[i].url, dataArray[i].jsonObj);\n          paramsArray[i].PAGE_TITLE = dataArray[i].title;\n\n          for (var item in dataArray[i].options) {\n            paramsArray[i][item] = dataArray[i].options[item];\n          }\n        }\n\n        JSBridge.callHandler(EJS_API, 'openPage', {\n          //1为是,其它为否\n          \"finishAfterOpen\": commonOptions.finishAfterOpen || '0',\n          //默认为1101\n          'requestCode': commonOptions.requestCode || '1101',\n          'data': paramsArray\n        }, function (res) {\n          if (res.code == '4') {\n            //默认只有状态为4时才回调\n            callback && callback(res.result, res.msg, res);\n          }\n        });\n      },\n\n      /**\n       * @description 打开原生页面\n       * 异步\n       * @param {String} localPageClassName 本地activity或viewController名称\n       * @param {JSON} jsonObj json参数 或者和下面的options合并成一个也行\n       * @param {JSON} options 额外的配置参数\n       * 包括 requestCode  请求code,startActivityForResult时需要用到,到时候用来进行页面传参\n       * 包括 viewtitle  h5页面title\n       * 包括 finishAfterOpen 是否打开下一个页面后关闭关闭当前页面 1为是,其它为否,默认为0\n       * @param {Function} callback 回调函数\n       * @param {Function} error 回调函数\n       */\n      openLocal: function openLocal(localPageClassName, jsonObj, options, callback, error) {\n        //jsonObj里面的额外参数 viewtitle()\n        //兼容jsonObj和options合并\n        jsonObj = jsonObj || {};\n\n        if (typeof arguments[2] === 'function') {\n          options = {};\n          callback = arguments[2];\n          error = arguments[3];\n        }\n\n        options = options || {}; //参数合并\n\n        jsonObj = ejs.extend(jsonObj, options, false);\n        JSBridge.callHandler(EJS_API, 'openLocal', {\n          \"localPageClassName\": localPageClassName,\n          //1为是,其它为否\n          \"finishAfterOpen\": options.finishAfterOpen || '0',\n          //默认为1101\n          'requestCode': options.requestCode || '1101',\n          'openExistLocal': options.openExistLocal || false,\n          'data': jsonObj\n        }, function (res) {\n          if (res.code == '4') {\n            //默认只有状态为4时才回调\n            callback && callback(res.result, res.msg, res);\n          } else if (res.code == '0') {\n            //默认只有状态为4时才回调\n            error && error(res);\n          }\n        });\n      },\n\n      /**\n       * @description 关闭当前页面，可以传入额外参数\n       * @param {JSON} extras 关闭时,传给打开页面的额外参数\n       * activit->finish\n       * ios->pop\n       * 异步\n       */\n      closePage: function closePage(extras) {\n        if (_typeof(extras) === 'object') {\n          extras = JSON.stringify(extras);\n        }\n\n        if (ejs.os.ejs) {\n          JSBridge.callHandler(EJS_API, 'closePage', {\n            \"resultData\": extras\n          }, function (res) {});\n        } else {\n          //浏览器退出\n          if (window.history.length > 1) {\n            window.history.back();\n            return true;\n          }\n        }\n      },\n\n      /**\n       * @deprecated 设置页面在恢复时，是否刷新页面元素(重新加载地址)\n       * 不推荐使用,请使用最新的 setResumeCallback\n       * @param {Function} callback 回调函数\n       */\n      setResumeReload: function setResumeReload(callback) {\n        JSBridge.callHandler(EJS_API, 'setResumeReload', {}, function (res) {\n          callback && callback(null, res.msg, res);\n        });\n      },\n\n      /**\n       * @description 设置页面在恢复时，触发回调\n       * 异步\n       * @param {Function} callback 回调函数,回调函数代表页面恢复了,页面可以做自己的逻辑\n       */\n      setResumeCallback: function setResumeCallback(callback) {\n        //设置一个页面resume的id\n        var callbackId = '10000002'; //注册长期回调\n\n        JSBridge.registerLongCallback(callbackId, function (res) {\n          if (res.code == '3') {\n            //默认只有状态为3时才回调\n            callback && callback(res.result, res.msg, res);\n          }\n        });\n        JSBridge.callHandler(EJS_API, 'setResumeCallback', {}, callbackId);\n      },\n\n      /**\n       * @description 重新加载页面\n       * 异步\n       * @param {Function} callback 回调函数\n       */\n      reloadPage: function reloadPage(callback) {\n        if (ejs.os.ejs) {\n          JSBridge.callHandler(EJS_API, 'reloadPage', {}, function (res) {\n            callback && callback(res.result, res.msg, res);\n          });\n        } else {\n          window.location.reload();\n        }\n      }\n    };\n    /**\n     ***NativeUI 模块 \n     */\n\n    ejs.nativeUI = {\n      /**\n       * @description toast提示信息\n       * 异步\n       * @param {JSON} options或者是message内容\n       * 包含 msg\n       */\n      toast: function toast(options) {\n        var msg = '';\n        options = options || {};\n\n        if (typeof options === 'string') {\n          msg = options;\n        } else {\n          msg = options.message;\n        }\n\n        JSBridge.callHandler(EJS_API, 'toast', {\n          'message': msg\n        }, function (res) {});\n      },\n\n      /**\n       * @description 只用于页面调试用\n       * 可复制信息以及发送信息\n       * @param {String} debugInfo\n       */\n      showDebugDialog: function showDebugDialog(debugInfo) {\n        JSBridge.callHandler(EJS_API, 'showDebugDialog', {\n          'debugInfo': debugInfo\n        }, function (res) {});\n\n        if (!ejs.os.ejs) {\n          ejs.nativeUI.alert(debugInfo);\n        }\n      },\n\n      /**\n       * @description 显示alert\n       * 异步\n       * @param {JSON} options或者是msg内容\n       * 包含 title,message\n       */\n      alert: function alert(options) {\n        var title = '',\n            msg = '';\n        options = options || {};\n\n        if (typeof options === 'string') {\n          msg = options;\n          title = arguments[1] || '';\n        } else {\n          msg = options.message;\n          title = options.title;\n        } //目前按钮名称不能自定义\n\n\n        JSBridge.callHandler(EJS_API, 'showMsgDialog', {\n          'title': title,\n          'message': msg\n        }, function (res) {});\n      },\n\n      /**\n       * @description 显示confirm\n       * iOS不支持cancelable参数设置\n       * 异步\n       * @param {JSON} options 额外配置参数\n       * title 标题\n       * message 消息内容\n       * btn1 第一个按钮\n       * btn2 第二个按钮\n       * cancelable 是否可取消\n       * @param {Function} callback 回调函数\n       * \n       */\n      confirm: function confirm(options, callback) {\n        options = options || {};\n\n        if (typeof options === 'string') {\n          options = {\n            'message': options\n          };\n\n          if (typeof arguments[1] === 'string') {\n            options.title = arguments[1];\n            callback = arguments[2];\n          }\n        } //目前按钮名称不能自定义\n\n\n        JSBridge.callHandler(EJS_API, 'showConfirmDialog', {\n          'title': options.title,\n          'message': options.message,\n          'btn1': options.btn1 || '取消',\n          'btn2': options.btn2 || (options.btn2 !== null ? '确定' : ''),\n          //默认为可取消\n          'cancelable': options.cancelable || 0\n        }, function (res) {\n          callback && callback(res.result, res.msg, res);\n        });\n      },\n\n      /**\n       * @description 创建输入对话框\n       * 显示输入框\n       * iOS 不支持cancelable参数设置\n       * 异步\n       * @param {JSON} options 额外配置参数\n       * title 标题\n       * hint 输入提示\n       * text 默认文本\n       * @param {Function} callback 回调函数\n       */\n      prompt: function prompt(options, callback) {\n        options = options || {}; //目前按钮名称不能自定义\n\n        JSBridge.callHandler(EJS_API, 'showEditTextDialog', {\n          'title': options.title,\n          'hint': options.hint,\n          'text': options.text,\n          'cancelable': options.cancelable || 0,\n          'lines': options.lines || 1,\n          'maxLength': options.maxLength || 10000\n        }, function (res) {\n          callback && callback(res.result, res.msg, res);\n        });\n      },\n\n      /**\n       * @description 显示列表选择对话框\n       * 支持单选和多选\n       * iOS不支持cancelable参数设置\n       * 异步\n       * @param {JSON} options 额外配置参数\n       * title 标题\n       * itemArray item数组\n       * checkState 设置为选择的array,multi时才有效\n       * cancelable 是否可以取消\n       * isMultiSelect 是否是多选，默认为false\n       * type 样式类型，默认为0。 0：单列表样式；1：九宫格样式(目前只支持单选)\n       * columns 九宫格列数，默认3列，只有当type为1时有效。\n       * @param {Function} callback 回调函数\n       * \n       */\n      select: function select(options, callback) {\n        options = options || {};\n        options.items = options.items || [];\n        options.checkState = options.checkState || [];\n        var isMultiSelect = options.isMultiSelect || false; //目前按钮名称不能自定义\n\n        JSBridge.callHandler(EJS_API, 'showSelectedDialog', {\n          'title': options.title,\n          'items': options.items.join(','),\n          'checkState': options.checkState.join(','),\n          //默认为可取消\n          'cancelable': options.cancelable || 0,\n          'isMultiSelect': isMultiSelect,\n          'type': options.type || 0,\n          'columns': options.columns || 3\n        }, function (res) {\n          //默认选择的items\n          var items = [];\n          var result = res.result;\n\n          if (isMultiSelect) {\n            //多选\n            var choiceState = result.choiceState;\n            choiceState = choiceState.split(',');\n            var choiceArray = [];\n\n            for (var i = 0, len = choiceState.length; i < len; i++) {\n              if (choiceState[i] != null && choiceState[i] != '') {\n                choiceArray.push(choiceState[i]);\n\n                if (choiceState[i] == '1') {\n                  items.push(options.items[i] || '');\n                }\n              }\n            }\n          } else {\n            //单选\n            var which = result.which;\n            var item = options.items[which];\n            items.push(item);\n          }\n\n          result.items = items;\n          callback && callback(res.result, res.msg, res);\n        });\n      },\n\n      /**\n       * @description 弹出底部选项按钮\n       * iOS 不支持cancelable参数设置\n       * 异步\n       * @param {JSON} options 额外配置参数\n       * items 内容\n       * cancelable 是否可取消\n       * @param {Function} callback 回调函数\n       * \n       */\n      actionSheet: function actionSheet(options, callback) {\n        options = options || {};\n        options.items = options.items || []; //目前按钮名称不能自定义\n\n        JSBridge.callHandler(EJS_API, 'showActionsheet', {\n          'items': options.items.join(','),\n          'cancelable': options.cancelable || 0\n        }, function (res) {\n          var index = -1;\n          var content = '';\n\n          if (res.result) {\n            index = res.result.which || 0;\n            content = options.items[index];\n            res.result.content = content;\n          }\n\n          callback && callback(res.result, res.msg, res);\n        });\n      },\n\n      /**\n       * @description 弹出顶部窗口选项按钮\n       * 有横向菜单和垂直菜单2种\n       * 可配合setNBRightImage、setNBRightText使用(iOS 不可配合使用)\n       * 异步\n       * @param {JSON} options 额外配置参数\n       * titleItems 标题内容\n       * iconItems 图标内容\n       * orientation 菜单类别。仅为\"horizontal\"时弹出横向菜单，否则弹出垂直菜单。\n       * @param {Function} callback 回调函数\n       * \n       */\n      popWindow: function popWindow(options, callback) {\n        options = options || {};\n        options.titleItems = options.titleItems || [];\n        options.iconItems = options.iconItems || [];\n        JSBridge.callHandler(EJS_API, 'showPopupWindow', {\n          'titleItems': options.titleItems.join(','),\n          'iconItems': options.iconItems.join(','),\n          'orientation': options.orientation || ''\n        }, function (res) {\n          callback && callback(res.result, res.msg, res);\n        });\n      },\n\n      /**\n       * @description 日期选择\n       * 部分设备上设置标题后遮挡控件可不设置标题\n       * cancelable默认为true，且无法设置\n       * 异步\n       * @param {JSON} options 额外配置参数\n       * title 标题\n       * datetime 指定日期，默认当前日期。格式为 yyyy-MM-dd。\n       * @param {Function} callback 回调函数\n       */\n      pickDate: function pickDate(options, callback) {\n        options = options || {}; //目前按钮名称不能自定义\n\n        JSBridge.callHandler(EJS_API, 'showDatePickDialog', {\n          'title': options.title,\n          'datetime': options.datetime\n        }, function (res) {\n          callback && callback(res.result, res.msg, res);\n        });\n      },\n\n      /**\n       * @description 时间选择\n       * 显示时间选择对话框\n       * cancelable默认为true，且无法设置\n       * 异步\n       * @param {JSON} options 额外配置参数\n       * title 标题\n       * datetime 指定日期，默认当前日期。格式为 yyyy-MM-dd HH:mm\n       * @param {Function} callback 回调函数\n       */\n      pickTime: function pickTime(options, callback) {\n        options = options || {}; //目前按钮名称不能自定义\n\n        JSBridge.callHandler(EJS_API, 'showTimePickDialog', {\n          'title': options.title,\n          'datetime': options.datetime\n        }, function (res) {\n          callback && callback(res.result, res.msg, res);\n        });\n      },\n\n      /**\n       * @description 日期时间选择\n       * 显示日期时间选择对话框\n       * cancelable默认为true，且无法设置\n       * 异步\n       * @param {JSON} options 额外配置参数\n       * title1 日期选择控件标题\n       * title2 时间选择控件标题\n       * datetime 指定日期，默认当前日期。格式为 yyyy-MM-dd。\n       * @param {Function} callback 回调函数\n       */\n      pickDateTime: function pickDateTime(options, callback) {\n        options = options || {}; //目前按钮名称不能自定义\n\n        JSBridge.callHandler(EJS_API, 'showDateTimePickDialog', {\n          'title1': options.title1,\n          'title2': options.title2,\n          'datetime': options.datetime\n        }, function (res) {\n          callback && callback(res.result, res.msg, res);\n        });\n      },\n\n      /**\n       * @description 显示等待对话框\n       * 异步\n       */\n      showWaiting: function showWaiting(title, callback) {\n        JSBridge.callHandler(EJS_API, 'showProgress', {}, function (res) {\n          callback && callback(res.result, res.msg, res);\n        });\n      },\n\n      /**\n       * @description 显示遮罩\n       */\n      showMask: function showMask() {\n        if (!this.mask) {\n          this.mask = mui.createMask();\n        }\n\n        this.mask.show();\n      },\n\n      /**\n       * @description 隐藏遮罩\n       */\n      hideMask: function hideMask() {\n        if (this.mask) {\n          this.mask.close();\n        }\n      },\n\n      /**\n       * @description 隐藏等待对话框\n       * 异步\n       */\n      closeWaiting: function closeWaiting() {\n        JSBridge.callHandler(EJS_API, 'hideProgress', {}, function (res) {});\n      },\n      //下拉刷新模块 pullToRefresh\n      pullToRefresh: {\n        /**\n         * @description 禁用下拉刷新\n         * 异步\n         */\n        disable: function disable() {\n          JSBridge.callHandler(EJS_API, 'setSwipeRefreshEnable', {\n            'swipeRefreshEnable': false\n          }, function (res) {});\n        },\n\n        /**\n         * @description 启用下拉刷新\n         * 异步\n         * @param {Function} callback 每次下拉会调用的回调\n         */\n        enable: function enable(callback) {\n          //设置一个专属的下拉刷新id\n          var callbackId = '10000001'; //注册长期回调\n\n          JSBridge.registerLongCallback(callbackId, function (res) {\n            if (res.code == '2') {\n              //默认只有状态为2时才回调\n              callback && callback(res.result, res.msg, res);\n            }\n          });\n          JSBridge.callHandler(EJS_API, 'setSwipeRefreshEnable', {\n            'swipeRefreshEnable': true\n          }, callbackId);\n        },\n\n        /**\n         * @description 收起下拉刷新loading\n         * 异步\n         */\n        stop: function stop() {\n          JSBridge.callHandler(EJS_API, 'stopSwipeRefresh', {}, function (res) {});\n        }\n      }\n    };\n    /**\n     ***Navigator 模块 \n     * 包括原生页面title操作以及部分导航栏操作\n     */\n\n    ejs.navigator = {\n      /**\n       * @description 显示导航栏\n       */\n      showNavigation: function showNavigation() {\n        JSBridge.callHandler(EJS_API, 'showNavigation', {}, function (res) {});\n      },\n\n      /**\n       * @description 隐藏导航栏\n       */\n      hideNavigation: function hideNavigation() {\n        JSBridge.callHandler(EJS_API, 'hideNavigation', {}, function (res) {});\n      },\n\n      /**\n       * @description 设置页面标题\n       * 建议通过openPage调用，将标题传递给下个页面\n       * 异步\n       * @param {String} title\n       */\n      setTitle: function setTitle(title) {\n        title = title || '';\n        JSBridge.callHandler(EJS_API, 'setNaigationTitle', {\n          \"PAGE_TITLE\": title\n        }, function (res) {});\n      },\n\n      /**\n       * @description 设置导航栏右上角文字按钮\n       * 需要设置的按钮文字,若为空则隐藏按钮。页面需要实现 onClickNBRightEJS()函数来接收点击事件。\n       * @param {String} title\n       * @param {Function} callback\n       */\n      setRightTextBtn: function setRightTextBtn(title, callback) {\n        title = title || '';\n        JSBridge.callHandler(EJS_API, 'setNBRightText', {\n          \"nbRightText\": title\n        }, function (res) {});\n\n        if (callback) {\n          //监听右侧事件\n          window.onClickNBRightEJS = function () {\n            callback && callback();\n          };\n        }\n      },\n\n      /**\n       * @description 设置导航栏右上角图片按钮\n       * 仅支持设置应用中的资源图片,传图片名称,若为空则隐藏按钮。页面需要实现onClickNBRightEJS()函数来接收点击事件。\n       * @param {String} localImgUrl\n       */\n      setRightImageBtn: function setRightImageBtn(localImgUrl) {\n        JSBridge.callHandler(EJS_API, 'setNBRightImage', {\n          \"nbRightImage\": localImgUrl\n        }, function (res) {});\n      },\n\n      /**\n       * 隐藏页面返回按钮\n       * 异步\n       */\n      hideBackButton: function hideBackButton() {\n        JSBridge.callHandler(EJS_API, 'hideBackButton', {}, function (res) {});\n      },\n\n      /**\n       * 显示原生搜索栏\n       * 异步\n       */\n      showSearchBar: function showSearchBar() {\n        JSBridge.callHandler(EJS_API, 'showSearchBar', {}, function (res) {});\n      },\n\n      /**\n       * 隐藏原生搜索栏\n       * 异步\n       */\n      hideSearchBar: function hideSearchBar() {\n        JSBridge.callHandler(EJS_API, 'hideSearchBar', {}, function (res) {});\n      },\n\n      /**\n       * 设置webview默认背景色\n       * 该设置为全局设置，数据保存本地数据库，V6中对应的key值是FrmConfigKeys_EjsBgColor，通过getConfigValue可获取。\n       * 异步\n       * @param {String} color 对应颜色\n       * 只支持16进制形式\n       */\n      setBgColor: function setBgColor(color) {\n        JSBridge.callHandler(EJS_API, 'setBgColor', {\n          \"Color\": color\n        }, function (res) {});\n      },\n\n      /**\n       * 设置导航栏主题\n       * 设置主题后修改所有页面导航栏的背景色，文字颜色以及图片\n       * V6框架中主题初始化在代码中写死了，如果需要个性化主题请原生开发人员手动添加。Android代码路径：com.epoint.frame.action.theme.ThemeConfig\n       * 异步\n       * @param {String} themeId 对应的皮肤id,原生内置\n       * 框架目前提供的ThemeId有（请以项目实际代码为准）：\n       * theme_default_blue(默认蓝色)、\n       * theme_black、theme_red、\n       * theme_sky、theme_water、\n       * theme_mount、theme_night。\n       * 其它需要自行拓展\n       */\n      setNbBarTheme: function setNbBarTheme(themeId) {\n        JSBridge.callHandler(EJS_API, 'setNbBarTheme', {\n          \"ThemeId\": themeId\n        }, function (res) {});\n      },\n\n      /**\n       * @description 设置全局的skin\n       * 这个api里内置了一些适合业务的webviewbg和barbg\n       * @param {String} skin 相应的skin\n       * 目前包括  default,day,night\n       */\n      setSkinTheme: function setSkinTheme(skin) {\n        skin = skin || 'default';\n\n        if (skin === 'day') {\n          ejs.navigator.setBgColor('ffffff');\n          ejs.navigator.setNbBarTheme('theme_default_blue');\n        } else if (skin === 'night') {\n          ejs.navigator.setBgColor('1a1a1a');\n          ejs.navigator.setNbBarTheme('theme_night');\n        } else {\n          //default\n          //暂时使用和日间相同的设置\n          ejs.navigator.setBgColor('ffffff');\n          ejs.navigator.setNbBarTheme('theme_default_blue');\n        }\n      }\n    };\n    /**\n     ***Sql 模块 \n     * 包括原生的数据库键值操作\n     */\n\n    ejs.sql = {\n      /**\n       * @description 获取原生数据库中的键值对\n       * 异步\n       * @param {String} callback key\n       * @param {Function} callback 回调函数\n       */\n      getConfigValue: function getConfigValue(key, callback, defaultValue) {\n        key = key || '';\n        JSBridge.callHandler(EJS_API, 'getConfigValue', {\n          \"config_key\": key\n        }, function (res) {\n          res = res || {};\n          callback && callback(res.result, res.msg, res);\n        });\n      },\n\n      /**\n       * @description 设置原生数据库中的键值对\n       * 异步\n       * @param {String}  key\n       * @param {String}  value\n       * @param {Function} callback 回调函数\n       */\n      setConfigValue: function setConfigValue(key, value, callback) {\n        key = key || '';\n        JSBridge.callHandler(EJS_API, 'setConfigValue', {\n          \"config_key\": key,\n          \"config_value\": value\n        }, function (res) {\n          res = res || {};\n          callback && callback(res.result, res.msg, res);\n        });\n      }\n    };\n    /**\n     ***Oauth 模块 \n     * 授权认证相关,如获取原生的token\n     */\n\n    ejs.oauth = {\n      /**\n       * @description 获取Token值\n       * 异步\n       * @param {Function} callback 回调函数,回调token值\n       */\n      getToken: function getToken(callback, defaultValue) {\n        JSBridge.callHandler(EJS_API, 'getToken', {}, function (res) {\n          res = res || {};\n          callback && callback(res.result, res.msg, res);\n        });\n      },\n\n      /**\n       * @description 获取App应用Guid，与中间平台配置的应用guid匹配\n       * 演示版本返回\"moa_app_standard_v6\"\n       * 异步\n       * @param {Function} callback 回调函数\n       */\n      getAppGuid: function getAppGuid(callback) {\n        JSBridge.callHandler(EJS_API, 'getAppGuid', {}, function (res) {\n          res = res || {};\n          callback && callback(res.result, res.msg, res);\n        });\n      }\n    };\n    /**\n     ***runtime 模块 \n     * 运行环境管理，包括应用间的通信等\n     */\n\n    ejs.runtime = {\n      /**\n       * @description 调用第三方应用\n       * 异步\n       * @param {JSON} options 相关参数\n       * 除了Param参数由H5提供，其他参数都要原生开发人员提供。\n       * android有下面4种方式打开第三方app（优先级从上至下）：\n       * 传PackageName+ClassName：打开指定页面；\n       * 只传PackageName：打开app的启动页面；\n       * 只传ActionName：打开指定页面；\n       * 只传Scheme：打开指定页面。\n       * @param {Function} callback 回调函数\n       */\n      launchApp: function launchApp(options, callback) {\n        options = options || {};\n        JSBridge.callHandler(EJS_API, 'openApp', {\n          \"PackageName\": options.PackageName,\n          \"ClassName\": options.ClassName,\n          \"ActionName\": options.ActionName,\n          \"Scheme\": options.Scheme,\n          \"Param\": options.Param\n        }, function (res) {\n          res = res || {};\n          callback && callback(res.result, res.msg, res);\n        });\n      },\n\n      /**\n       * @description 获取系统版本号名称\n       * @param {JSON} options\n       * @param {Function} callback\n       */\n      getVersionName: function getVersionName(options, callback) {\n        options = options || {};\n\n        if (typeof options === 'function') {\n          callback = options;\n        }\n\n        JSBridge.callHandler(EJS_API, 'getVersionName', {}, function (res) {\n          res = res || {};\n          callback && callback(res.result, res.msg, res);\n        });\n      },\n\n      /**\n       * @description 清除缓存\n       * 会清楚webview的图片缓存，历史记录等存在内存中的信息\n       * @param {JSON} options\n       * @param {Function} callback\n       */\n      clearCache: function clearCache(options, callback) {\n        options = options || {};\n\n        if (typeof options === 'function') {\n          callback = options;\n        }\n\n        JSBridge.callHandler(EJS_API, 'clearCache', {}, function (res) {\n          res = res || {};\n          callback && callback(res.result, res.msg, res);\n        });\n      }\n    };\n    /**\n     ***device 模块 \n     * 设备信息相关\n     */\n\n    ejs.device = {\n      /**\n       * @description 获取当前网络状态\n       * 异步\n       * @param {Function} callback 对应的回调函数\n       * \n       */\n      getNetWorkType: function getNetWorkType(callback) {\n        JSBridge.callHandler(EJS_API, 'getNetWorkType', {}, function (res) {\n          //回调参数示例 {\"result\":{'NetWorkType':1(-1:无网络； 1：wifi； 0：移动网络)}}\n          callback && callback(res.result, res.msg, res);\n        });\n      },\n\n      /**\n       * @description 强制设置屏幕的方向\n       * Android中对首页的Fragment无效\n       * 异步\n       * @param {String} orientation \n       * 为\"1\"时强制竖屏；为\"0\"时强制横屏；其他按照系统设置旋转。\n       */\n      setOrientation: function setOrientation(orientation) {\n        JSBridge.callHandler(EJS_API, 'setOrientation', {\n          //默认是跟随系统设置\n          'orientation': orientation || '2'\n        }, function (res) {\n          res = res || {};\n          callback && callback(res.result, res.msg, res);\n        });\n      },\n\n      /**\n       * @description 获取屏幕分辨率\n       * @param {Function} callback 回调函数\n       */\n      getPixel: function getPixel(callback) {\n        JSBridge.callHandler(EJS_API, 'getPixel', {}, function (res) {\n          res = res || {};\n          callback && callback(res.result, res.msg, res);\n        });\n      },\n\n      /**\n       * @description 获取设备厂商以及型号\n       * @param {Function} callback 回调函数\n       */\n      getUAinfo: function getUAinfo(callback) {\n        JSBridge.callHandler(EJS_API, 'getUAinfo', {}, function (res) {\n          res = res || {};\n          callback && callback(res.result, res.msg, res);\n        });\n      },\n\n      /**\n       * @description 获取设备Mac地址（iOS 不支持该API）\n       * 如果Wifi关闭的时候，可能返回空\n       * 异步\n       * @param {Function} callback 回调函数\n       */\n      getMacAddress: function getMacAddress(callback) {\n        JSBridge.callHandler(EJS_API, 'getMacAddress', {}, function (res) {\n          res = res || {};\n          callback && callback(res.result, res.msg, res);\n        });\n      },\n\n      /**\n       * @description 获取设备机器码\n       * 双卡手机切换sim卡或者系统重置后可能会变\n       * 如果机器码为空则返回mac地址\n       * 异步\n       * @param {Function} callback 回调函数\n       */\n      getDeviceId: function getDeviceId(callback) {\n        JSBridge.callHandler(EJS_API, 'getDeviceid', {}, function (res) {\n          res = res || {};\n          callback && callback(res.result, res.msg, res);\n        });\n      },\n\n      /**\n       * @description 打电话\n       * 异步\n       * @param {JSON} options\n       * phoneNum 电话号码\n       * @param {Function} callback 回调函数\n       */\n      callPhone: function callPhone(options, callback) {\n        options = options || {};\n\n        if (typeof options === 'string') {\n          options = {\n            phoneNum: options\n          };\n        }\n\n        JSBridge.callHandler(EJS_API, 'call', {\n          \"phoneNum\": options.phoneNum\n        }, function (res) {\n          callback && callback(res.result, res.msg, res);\n        });\n      },\n\n      /**\n       * @description 发短信\n       * 进入手机短信编辑界面\n       * 异步\n       * @param {JSON} options\n       * phoneNum 电话号码\n       * message 短信内容\n       * @param {Function} callback 回调函数\n       */\n      sendMsg: function sendMsg(options, callback) {\n        options = options || {};\n\n        if (typeof options === 'string') {\n          options = {\n            phoneNum: options,\n            message: arguments[1]\n          };\n          callback = arguments[2];\n        }\n\n        JSBridge.callHandler(EJS_API, 'sendMsg', {\n          \"phoneNum\": options.phoneNum,\n          \"message\": options.message\n        }, function (res) {\n          callback && callback(res.result, res.msg, res);\n        });\n      },\n\n      /**\n       * @description 是否平板设备\n       * 异步\n       * @param {Function} callback 回调函数\n       */\n      isTablet: function isTablet(callback) {\n        JSBridge.callHandler(EJS_API, 'isTablet', {}, function (res) {\n          res = res || {};\n          callback && callback(res.result, res.msg, res);\n        });\n      }\n    };\n    /**\n     ***app 模块 \n     * 一些其它的杂七杂八的操作\n     */\n\n    ejs.app = {\n      /**\n       * @description 通过传入key值,得到页面key的初始化传值\n       * 实际情况是获取 window.location.href 中的参数的值\n       * 同步\n       * @param {String} key\n       */\n      getExtraDataByKey: function getExtraDataByKey(key) {\n        if (!key) {\n          return null;\n        } //获取url中的参数值\n\n\n        var getUrlParamsValue = function getUrlParamsValue(url, paramName) {\n          var paraString = url.substring(url.indexOf(\"?\") + 1, url.length).split(\"&\");\n          var paraObj = {};\n          var i, j;\n\n          for (i = 0; j = paraString[i]; i++) {\n            paraObj[j.substring(0, j.indexOf(\"=\")).toLowerCase()] = j.substring(j.indexOf(\"=\") + 1, j.length);\n          }\n\n          var returnValue = paraObj[paramName.toLowerCase()]; //需要解码浏览器编码\n\n          returnValue = decodeURIComponent(returnValue);\n\n          if (typeof returnValue == \"undefined\") {\n            return undefined;\n          } else {\n            return returnValue;\n          }\n        };\n\n        var value = getUrlParamsValue(window.location.href, key);\n\n        if (value === 'undefined') {\n          value = null;\n        }\n\n        return value;\n      },\n\n      /**\n       * @description 添加参数到url上\n       * @param {String} url\n       * @param {JSON} jsonObj\n       */\n      appendParams: function appendParams(url, jsonObj) {\n        return getFullUrlByParams(url, jsonObj);\n      }\n    };\n    /**\n     *** nativeComponents\n     * 原生组件模块\n     */\n\n    ejs.nativeComponents = {\n      /**\n       * @description 打开二维码扫描功能\n       * @param {JSON} options 额外参数\n       * isOrientationLocked 扫码界面是否固定竖屏，仅当值为'0'时不固定\n       * @param {Function} callback 回调函数\n       * @param {Function} error 错误回调\n       */\n      openScan: function openScan(options, callback, error) {\n        options = options || {};\n        JSBridge.callHandler(EJS_API, 'openScan', {\n          \"isOrientationLocked\": options.isOrientationLocked || '0'\n        }, function (res) {\n          if (res.code == '4') {\n            //默认只有状态为4时才回调\n            callback && callback(res.result, res.msg, res);\n          } else if (res.code == '0') {\n            error && error(res);\n          }\n        });\n      },\n\n      /**\n       * @description 下载文件\n       * 下载完成后自动打开文件。\n       * 最大并发下载数5，超出部分等前面下载完成后自动下载\n       * \n       * @param {JSON} options 额外参数\n       * reDownloaded 是否重新下载。\n       * reDownloader这个参数iOS未处理\n       * 如果本地已有该文件是否重新下载。默认直接打开文件，为\"1\"时重新下载文件并且重命名。\n       * 命名规则：原文件名_数字.后缀名。数字从1开始逐次递加,直到不再是重复名字。\n       * url 下载地址。\n       * fileName 文件名。如果为空，会根据url地址或者头文件中读取出文件名。。\n       * @param {Function} callback 回调函数\n       * @param {Function} error 错误回调\n       * \n       */\n      downloadFile: function downloadFile(options, callback, error) {\n        options = options || {};\n        JSBridge.callHandler(EJS_API, 'downloadFile', {\n          //下载分类。默认不分类，保存路径统一为\"/sacard/epointapp/attach/\"。\n          //框架提供的指定分类有待办(TODO)，邮件(MAIL)，分类信息(CLASSITFY)，\n          //网络硬盘(NETDISK)，微消息(IM)，分别对应不同模块的附件下载，有对应的保存路径，\n          //指定分类后可在\"附件管理\"模块查看附件。另外还可以个性化分类，但需要原生开发配合新增类别。\n          //如果没有\"附件管理\"模块，可忽略该参数。\n          \"type\": options.type || '其他',\n          \"reDownloaded\": options.reDownloaded,\n          \"url\": options.url,\n          \"fileName\": options.fileName,\n          \"isBackground\": options.isBackground || 0\n        }, function (res) {\n          if (res.code == '1') {\n            //默认只有状态为4时才回调\n            callback && callback(res.result, res.msg, res);\n          } else if (res.code == '0') {\n            error && error(res);\n          }\n        });\n      },\n\n      /**\n       * @description 打开通用历史搜索界面\n       * 支持手动和语音输入。\n       * 语音输入需要讯飞sdk。\n       * @param {JSON} options 额外参数\n       * hint 输入框提示文字\n       * @param {Function} callback 回调函数\n       * @param {Function} error 错误回调\n       */\n      historySearch: function historySearch(options, callback, error) {\n        options = options || {};\n        JSBridge.callHandler(EJS_API, 'historySearch', {\n          \"hint\": options.hint\n        }, function (res) {\n          if (res.code == '4') {\n            //默认只有状态为4时才回调\n            callback && callback(res.result, res.msg, res);\n          } else if (res.code == '0') {\n            error && error(res);\n          }\n        });\n      },\n\n      /**\n       * @description 打开本地通讯录选人组件\n       * 同步完组织架构才能正常选择人员\n       * iOS原生组件不支持单选\n       * @param {JSON} options 额外参数\n       * chooseType 选择类别，0代表多选，1代表单选\n       * @param {Function} callback 回调函数\n       * @param {Function} error 错误回调\n       * selectedInfo\n       * 已选人员信息。若非空则表示多选。值为人员信息的json数组。json对象格式需要符合以下规则：\n       * key值为人员userguid，value值为人员信息键值对。\n       * 人员信息可根据业务实际需求填写，传递哪些参数回调时也返回这些参数。\n       * 参数包括UserGuid，LoginID，DisplayName，OUGuid，OrderNumber，Title，\n       * TelephoneOffice，TelephoneHome，Mobile，Email，Sex，Fax，PostalAddress，\n       * PostalCode，PhotoUrl，Description，ShortMobile，QQNumber，NTXExtNumber，\n       * NamePYShou，SequenceId，Mark。\n       */\n      selectContact: function selectContact(options, callback, error) {\n        options = options || {}; //{'transFilterNames':'张三;李四','transFilterGuids':'1001;1002'}\n\n        JSBridge.callHandler(EJS_API, 'selectContact', {\n          \"isSingle\": options.isSingle || '0',\n          \"selectedInfo\": options.selectedInfo,\n          //备选人员名字，多个用\";\"隔开。\n          \"transFilterNames\": options.transFilterNames || '',\n          //备选人员guid，多个用\";\"隔开。与transFilterNames一一对应。\n          \"transFilterGuids\": options.transFilterGuids || ''\n        }, function (res) {\n          if (res.code == '4' || res.code == '1') {\n            //默认只有状态为4时才回调\n            callback && callback(res.result, res.msg, res);\n          } else if (res.code == '0') {\n            error && error(res);\n          }\n        });\n      },\n\n      /**\n       * @description 多图片选择\n       * 选择过程中可进行已选图片预览。\n       * 回调获取的是图片本地路径。\n       * 可配合图片预览previewPics使用。\n       * @param {JSON} options 额外参数\n       * maxPic 可选图片的最大数。不能小于1。\n       * @param {Function} callback 回调函数\n       * @param {Function} error 错误回调函数\n       */\n      selectPics: function selectPics(options, callback, error) {\n        options = options || {};\n        JSBridge.callHandler(EJS_API, 'selectPics', {\n          \"maxPic\": options.maxPic\n        }, function (res) {\n          if (res.code == '4') {\n            //默认只有状态为4时才回调\n            callback && callback(res.result, res.msg, res);\n          } else if (res.code == '0') {\n            error && error(res);\n          }\n        });\n      },\n\n      /**\n       * @description 图片预览\n       * 支持网络图片，设备本地图片，应用资源图片。\n       * iOS中以\"file://\"开头，加载的是沙盒中的图片，fileGuid\n       * iOS中以“drawable://”开头，加载的是mainBundle中的图片，后面拼接的是图片的名字\n       * @param {JSON} options 额外参数\n       * url图片地址。网络图片以\"http://\"开头；设备本地路径以\"file://\"开头，\n       * 后面接文件sd卡路径，；用drawable中的资源文件以\"drawable://\"开头，\n       * 后面接图片名字；应用assets中的资源文件以\"assets://\"开头，后面接文件路径。\n       * index 默认显示图片序号。值为数字\n       */\n      previewPics: function previewPics(options) {\n        options = options || {};\n        JSBridge.callHandler(EJS_API, 'previewPics', {\n          \"url\": options.url,\n          'index': options.index || 0\n        }, function () {});\n      },\n\n      /**\n       * @description 检查app更新\n       */\n      updateApp: function updateApp() {\n        JSBridge.callHandler(EJS_API, 'updateApp', {}, function () {});\n      },\n\n      /**\n       * @description 系统分享\n       * 该api调用的是原生系统组件，不同手机展示的界面以及效果可能不一样\n       * 只能弹出手机中已安装的应用,包括qq，微信，微博，钉钉等\n       * 系统分享能力有限，如果需要更加强大的分享功能请使用sharesdk\n       * 参数SDPath仅android支持\n       * 参数shareImgURL仅iOS支持\n       * @param {JSON} options 额外参数\n       */\n      sysShare: function sysShare(options) {\n        options = options || {};\n        var title = '';\n\n        if (typeof options === 'string') {\n          title = options;\n        } else {\n          title = options.shareTitle;\n        }\n\n        JSBridge.callHandler(EJS_API, 'sysShare', {\n          'shareTitle': title || '',\n          'shareURL': options.shareURL,\n          'shareImgBase64': options.shareImgBase64,\n          'shareImgURL': options.shareImgURL,\n          'SDPath': options.SDPath\n        }, function () {});\n      },\n\n      /**\n       * @description 播放在线视频\n       * @param {JSON} options 额外参数\n       * videoUrl 视频地址，必填\n       * thumbUrl 缩略图地址，默认为空\n       * title 顶部标题，默认为空\n       * @param {Function} callback 回调函数\n       * @param {Function} error 错误回调\n       */\n      playVideo: function playVideo(options, callback, error) {\n        options = options || {};\n        JSBridge.callHandler(EJS_API, 'playVideo', {\n          \"videoUrl\": options.videoUrl || '',\n          \"thumbUrl\": options.thumbUrl || '',\n          \"title\": options.title || ''\n        }, function (res) {\n          if (res.code == '1') {\n            //默认只有状态为4时才回调\n            callback && callback(res.result, res.msg, res);\n          } else if (res.code == '0') {\n            error && error(res);\n          }\n        });\n      },\n      //收藏模块\n      //使用收藏相关API请升级框架核心类库(android升级至epointandroidcore_V2.1.jar以上版本) \n      //只返回保存为非空的字段以及CollectionTime(保存时间)字段\n      collection: {\n        /**\n         * @description 保存本地收藏信息\n         * 保存本地数据库，可用于离线查看\n         * 可根据实际业务需求灵活应用该API\n         * 返回code为1表示保存，否则保存失败\n         * @param {JSON} options 相关配置参数\n         * @param {Function} callback 回调函数\n         * @param {Function} error 错误回调\n         */\n        saveLocalCollections: function saveLocalCollections(options, callback, error) {\n          JSBridge.callHandler(EJS_API, 'saveLocalCollections', {\n            'MsgGuid': options.MsgGuid || '',\n            'Title': options.Title || '',\n            'DateTime': options.DateTime || '',\n            'Publisher': options.Publisher || '',\n            'Type': options.Type || '',\n            'URL': options.URL || '',\n            'Remark': options.Remark || '',\n            'Flag': options.Flag || ''\n          }, function (res) {\n            if (res.code == '1') {\n              callback && callback(res.result, res.msg, res);\n            } else {\n              error && error(res);\n            }\n          });\n        },\n\n        /**\n         * @description 获取本地收藏信息\n         * @param {params} options 配置参数\n         * pageIndex 从第一页开始\n         * pageSize 默认是10\n         * @param {Function} callback 回调函数\n         */\n        getLocalCollections: function getLocalCollections(options, callback) {\n          if (typeof arguments[0] === 'function') {\n            callback = _typeof(arguments[0]);\n            options = {};\n          }\n\n          options = options || {};\n          JSBridge.callHandler(EJS_API, 'getLocalCollections', {\n            'pageIndex': options.pageIndex || 1,\n            'pageSize': options.pageSize || 10\n          }, function (res) {\n            //{'collectionInfo':[{\"CollectionTime\":\"2016-12-26 16:26:14\",\"Type\":\"test\",\"MsgGuid\":\"1\",\"DateTime\":\"2016.12.26 15:20\",\"Title\":\"收藏title\"}]}\n            callback && callback(res.result, res.msg, res);\n          });\n        },\n\n        /**\n         * @description 判断是否收藏\n         * @param {String} MsgGuid 信息guid\n         * @param {Function} callback 回调函数\n         */\n        isCollection: function isCollection(MsgGuid, callback) {\n          JSBridge.callHandler(EJS_API, 'isCollection', {\n            'MsgGuid': MsgGuid\n          }, function (res) {\n            //{'isCollection':'1'（1表示收藏 0表示未收藏）}\n            callback && callback(res.result, res.msg, res);\n          });\n        },\n\n        /**\n         * @description 取消本地收藏信息\n         * 返回code为1表示删除成功，否则删除失败\n         * @param {String} MsgGuid 信息guid\n         * @param {Function} callback 回调函数\n         * @param {Function} error 错误回调\n         */\n        delCollection: function delCollection(MsgGuid, callback, error) {\n          JSBridge.callHandler(EJS_API, 'delCollection', {\n            //信息guid\n            'MsgGuid': MsgGuid\n          }, function (res) {\n            if (res.code == '1') {\n              callback && callback(res.result, res.msg, res);\n            } else {\n              error && error(res);\n            }\n          });\n        },\n\n        /**\n         * @description 清空本地所有收藏信息\n         * 如果有登录帐号，则只会删除该帐号收藏的所有信息\n         * 返回code为1表示删除成功，否则删除失败\n         * @param {Function} callback 回调函数\n         * @param {Function} error 错误回调\n         */\n        delAllCollections: function delAllCollections(callback, error) {\n          JSBridge.callHandler(EJS_API, 'delAllCollections', {}, function (res) {\n            if (res.code == '1') {\n              callback && callback(res.result, res.msg, res);\n            } else {\n              error && error(res);\n            }\n          });\n        }\n      }\n    };\n    /**\n     * @description 调用ejs的错误回调\n     * @param {Function} callback 回调函数\n     */\n\n    ejs.error = function (callback) {\n      globalError = callback;\n    };\n    /**\n     * @description ready方法\n     * 目前暂时不做操作，作为保留方法\n     * @param {Function} callback 回调函数\n     */\n\n\n    ejs.ready = function (callback) {\n      callback && callback();\n    };\n    /**\n     * @description 调用ejs的自定义方法\n     * @param {String} handlerName 方法名\n     * @param {JSON} data 额外参数\n     * @param {Function} callback 回调函数\n     * @param {String} proto 协议头,默认为epoint_bridge_custom\n     */\n\n\n    ejs.call = function (handlerName, data, callback, proto) {\n      proto = proto || EJS_API_CUSTOM;\n      data = data || {};\n      JSBridge.callHandler(proto, handlerName, data, function (res) {\n        callback && callback(res.result, res.msg, res);\n      });\n    };\n\n    exports.version = '2.1.6';\n    return exports;\n  }(global.ejs = {}, false);\n});",null]}