{"remainingRequest":"/Users/gujiahao/Documents/work/github/artweb/node_modules/thread-loader/dist/cjs.js!/Users/gujiahao/Documents/work/github/artweb/node_modules/babel-loader/lib/index.js!/Users/gujiahao/Documents/work/github/artweb/node_modules/@vue/cli-plugin-eslint/node_modules/eslint-loader/index.js??ref--13-0!/Users/gujiahao/Documents/work/github/artweb/src/utils/date.js","dependencies":[{"path":"/Users/gujiahao/Documents/work/github/artweb/src/utils/date.js","mtime":1588230106649},{"path":"/Users/gujiahao/Documents/work/github/artweb/node_modules/cache-loader/dist/cjs.js","mtime":1579587180818},{"path":"/Users/gujiahao/Documents/work/github/artweb/node_modules/thread-loader/dist/cjs.js","mtime":1579587183081},{"path":"/Users/gujiahao/Documents/work/github/artweb/node_modules/babel-loader/lib/index.js","mtime":1585810045725},{"path":"/Users/gujiahao/Documents/work/github/artweb/node_modules/@vue/cli-plugin-eslint/node_modules/eslint-loader/index.js","mtime":1579587173378}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.reflect.construct\";\nimport \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es6.regexp.match\";\nimport _classCallCheck from \"/Users/gujiahao/Documents/work/github/artweb/node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/gujiahao/Documents/work/github/artweb/node_modules/@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _inherits from \"/Users/gujiahao/Documents/work/github/artweb/node_modules/@babel/runtime-corejs2/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/Users/gujiahao/Documents/work/github/artweb/node_modules/@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/gujiahao/Documents/work/github/artweb/node_modules/@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _wrapNativeSuper from \"/Users/gujiahao/Documents/work/github/artweb/node_modules/@babel/runtime-corejs2/helpers/esm/wrapNativeSuper\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * 将字符串多余的长度补齐0\n * @param {String} s 需补齐的字符串\n * @param {Number} len 补齐长度\n * @return {String} 补齐后的字符串\n */\nvar paddingFillWith0 = function paddingFillWith0(s, len) {\n  len -= \"\".concat(s).length;\n\n  for (var i = 0; i < len; i++) {\n    s = \"0\".concat(s);\n  }\n\n  return s;\n};\n/**\n * 日期匹配的正则表达式\n * Y:年\n * M:月\n * D:日\n * h:小时\n * m:分钟\n * s:秒\n * i:毫秒\n * w:星期(小写的)\n * W:星期(大写的)\n */\n\n\nvar SIGN_DATE_REG = /([YyMDdHhmsiWw])(\\1*)/g;\n/**\n * 默认的pattern\n * 'YYYY-MM-DD hh:mm:ss:iii'\n */\n\nvar DEFAULT_PATTERN = 'YYYY-MM-DD hh:mm:ss:iii';\n\nvar MyDate = /*#__PURE__*/function (_Date) {\n  _inherits(MyDate, _Date);\n\n  var _super = _createSuper(MyDate);\n\n  function MyDate() {\n    _classCallCheck(this, MyDate);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(MyDate, [{\n    key: \"parseDate\",\n\n    /**\n     * 定义静态方法，解析成拓展的日期对象\n     * @param {String} dateString 日期字符串\n     * @param {String} pattern 匹配字符串,可以手动传入,或者采取默认\n     * @return {MyDate} 返回一个MyDate对象\n     */\n    value: function parseDate(dateString, pattern) {\n      if (!dateString || typeof dateString === 'number') {\n        // 普通的构造，时间戳、纯数字以及其它多参数构造情况（多参数情况，第一个参数也是数字）\n        return new Date();\n      }\n\n      try {\n        dateString = dateString || ''; // 判断需要的匹配模式\n\n        pattern = pattern || DEFAULT_PATTERN; // 格式的正则匹配式，譬如YYYY-MM-DD hh:mm:ss:iii\n\n        var matchs1 = pattern.match(SIGN_DATE_REG); // 值的正则匹配式，将实际的时间数据提取出来，和前面一一对应\n        // 譬如 2018-01-01 01:01:01:000\n        // 当然，前提是数字间有分隔符，否则无法\n\n        var matchs2 = dateString.match(/(\\d)+/g);\n\n        if (matchs1.length > 0) {\n          // 必须第一个匹配式匹配到（否则就是格式错误了）\n          // 先生成一个最原始的时间-1970-01-01年的\n          var myDate = new MyDate(1970, 0, 1); // 遍历,分别设置年月日,分秒等等\n\n          for (var i = 0, len = matchs1.length; i < len; i++) {\n            // 这个分别是  年,月,日  时,分,秒等等\n            // 增加默认值0,防止当没有数据时出错\n            var mTarget = parseInt(matchs2[i], 10) || 0; // 判断YMDhmsiw等等关键字\n            // 这个matchs1[i]有可能是YYYY，MM之类，所以只需取第一个字符\n\n            switch (matchs1[i].charAt(0) || '') {\n              case 'Y':\n                myDate.setFullYear(mTarget);\n                break;\n\n              case 'M':\n                myDate.setMonth(mTarget - 1);\n                break;\n\n              case 'D':\n                myDate.setDate(mTarget);\n                break;\n\n              case 'h':\n                myDate.setHours(mTarget);\n                break;\n\n              case 'm':\n                myDate.setMinutes(mTarget);\n                break;\n\n              case 's':\n                myDate.setSeconds(mTarget);\n                break;\n\n              case 'i':\n                myDate.setMilliseconds(mTarget);\n                break;\n\n              default:\n                // 默认不操作\n                break;\n            }\n          }\n\n          return myDate;\n        }\n      } catch (e) {}\n\n      throw new Error('解析成MyDate失败，请检查传入格式！');\n    }\n    /**\n     * 写自己的原型方法，这里实现一个按任何格式的输出方法\n     * @param {String} fmt 自己需要输出的格式，经典的yyyyMMddhhmmssiiww系列\n     * @return {String} 返回一个字符串\n     */\n\n  }, {\n    key: \"format\",\n    value: function format(fmt) {\n      var pattern = fmt || DEFAULT_PATTERN;\n      var value = this;\n      return pattern.replace(SIGN_DATE_REG, function ($0) {\n        // 如果传入一个yyyy-MM-dd 的表达式\n        // 实际上这个函数会分别回调多次 没符合一次匹配就回调一次\n        // $0:yyyy  $0:MM $0:dd  依次类推\n        switch ($0.charAt(0)) {\n          case 'Y':\n          case 'y':\n            return paddingFillWith0(value.getFullYear(), $0.length);\n\n          case 'M':\n            return paddingFillWith0(value.getMonth() + 1, $0.length);\n\n          case 'D':\n          case 'd':\n            return paddingFillWith0(value.getDate(), $0.length);\n\n          case 'H':\n          case 'h':\n            return paddingFillWith0(value.getHours(), $0.length);\n\n          case 'm':\n            return paddingFillWith0(value.getMinutes(), $0.length);\n\n          case 's':\n            return paddingFillWith0(value.getSeconds(), $0.length);\n\n          case 'i':\n            return paddingFillWith0(value.getMilliseconds(), $0.length);\n\n          case 'w':\n            return value.getDay();\n\n          case 'W':\n            // 自动将星期转为了大写\n            var week = ['日', '一', '二', '三', '四', '五', '六'];\n            return paddingFillWith0(week[value.getDay()], $0.length);\n\n          default:\n            return '';\n        }\n      });\n    }\n    /**\n     * 获取绝对毫秒数，这里补上了getTime造成的时区差\n     * @param {Boolean} isTimezoneOffsetFixed 是否补齐时区误差\n     * @return {Number} 返回绝对时间戳\n     */\n\n  }, {\n    key: \"getAbsoluteMillonsTime\",\n    value: function getAbsoluteMillonsTime(isTimezoneOffsetFixed) {\n      // 要补上与GMT时区的误差，时区差以分钟为单位，所以要换成毫秒\n      var offset = isTimezoneOffsetFixed ? this.getTimezoneOffset() * 60 * 1000 : 0;\n      return this.getTime() + offset;\n    }\n    /**\n     * 返回字符串时间戳\n     * @param {Boolean} isTimezoneOffsetFixed 是否补齐时区误差\n     * @return {String} 返回绝对时间戳，19700101到现在的\n     */\n\n  }, {\n    key: \"toTimeStap\",\n    value: function toTimeStap(isTimezoneOffsetFixed) {\n      return \"\".concat(this.getAbsoluteMillonsTime(isTimezoneOffsetFixed));\n    }\n    /**\n     * 返回往后n秒的时间\n     * @param {Number} num 往后几秒小时，默认为0\n     * @return {MyDate} 返回一个计算后的MyDate对象\n     */\n\n  }, {\n    key: \"nextSeconds\",\n    value: function nextSeconds(num) {\n      num = num || 1; // 通过毫秒计算，加上一个小时的毫秒数\n      // 构建时传入的时间是，和GMT时间1970年1月1日之间相差的毫秒数\n\n      return new MyDate(this.getTime() + num * 1000);\n    }\n  }, {\n    key: \"nextMinutes\",\n    value: function nextMinutes(num) {\n      num = num || 1;\n      return this.nextSeconds(60 * num);\n    }\n  }, {\n    key: \"nextHours\",\n    value: function nextHours(num) {\n      num = num || 1;\n      return this.nextMinutes(60 * num);\n    }\n  }, {\n    key: \"nextDays\",\n    value: function nextDays(num) {\n      num = num || 1;\n      return this.nextHours(24 * num);\n    }\n    /**\n     * 返回往后n月的时间，这里会自动计算每月的天数，1月后面就是2月，紧接着3月\n     * @param {Number} num 往后几秒小时，默认为0\n     * @return {MyDate} 返回一个计算后的MyDate对象\n     */\n\n  }, {\n    key: \"nextMonths\",\n    value: function nextMonths(num) {\n      num = num || 0; // 月份，0-11，所以补上1，凑成12进制\n\n      var originMonth = this.getMonth() + 1;\n      var originYear = this.getFullYear(); // 二月份要单独计算并赋值\n\n      var daysPerMonth = [31, 0, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n      var days = 0;\n\n      for (var i = 0; i < num; i++) {\n        var currMonth = originMonth + i;\n        var currYear = originYear + ~~(currMonth / 12);\n        var isLeapYear = currYear % 4 === 0 && (currYear % 100 !== 0 || currYear % 400 !== 0);\n\n        if (isLeapYear) {\n          daysPerMonth[1] = 29;\n        } else {\n          daysPerMonth[1] = 28;\n        } // 最多保留 1-12，13需要换算成1，然后重新开始\n\n\n        currMonth %= 12;\n\n        if (currMonth === 0) {\n          // 12, 24, 36这种，需要换成11，这点特殊处理（因为按上面计算会变为0）\n          currMonth = 11;\n        } else {\n          currMonth -= 1;\n        }\n\n        days += daysPerMonth[currMonth];\n      }\n\n      return this.nextDays(days);\n    }\n  }, {\n    key: \"nextYears\",\n    value: function nextYears(num) {\n      num = num || 0;\n      return this.nextMonths(12 * num);\n    }\n    /**\n     * 和另一个时间比较，必须也是MyDate类型\n     * @param {MyDate} another 另一个日期对象，也可以是一个普通的日期对象\n     * @param {String} pattern 模式字符串，需要比较到何等程度\n     * @return {Number} 返回一个便宜数字，大于0代表当前时间大于比较时间，小于0就是小于，否则等于\n     */\n\n  }, {\n    key: \"compare\",\n    value: function compare(another, pattern) {\n      if (!(another instanceof MyDate)) {\n        throw new Error('比较类型错误，必须是MyDate型');\n      } // 默认精确到秒\n\n\n      pattern = pattern || 's';\n      var formatPattern = '';\n\n      switch (pattern.charAt(0)) {\n        case 'Y':\n        case 'y':\n          formatPattern = 'YYYY';\n          break;\n\n        case 'M':\n          formatPattern = 'YYYYMM';\n          break;\n\n        case 'D':\n        case 'd':\n          formatPattern = 'YYYYMMDD';\n          break;\n\n        case 'H':\n        case 'h':\n          formatPattern = 'YYYYMMDDhh';\n          break;\n\n        case 'm':\n          formatPattern = 'YYYYMMDDhhmm';\n          break;\n\n        case 'S':\n        case 's':\n          formatPattern = 'YYYYMMDDhhmmss';\n          break;\n\n        case 'I':\n        case 'i':\n          formatPattern = 'YYYYMMDDhhmmssiii';\n          break;\n\n        default:\n          break;\n      }\n\n      var now = +this.format(formatPattern);\n      var anotherTime = +another.format(formatPattern);\n      return now - anotherTime;\n    }\n  }]);\n\n  return MyDate;\n}( /*#__PURE__*/_wrapNativeSuper(Date));\n\nexport default MyDate;",null]}