{"remainingRequest":"/Users/gujiahao/Documents/work/github/artweb/node_modules/thread-loader/dist/cjs.js!/Users/gujiahao/Documents/work/github/artweb/node_modules/babel-loader/lib/index.js!/Users/gujiahao/Documents/work/github/artweb/node_modules/@vue/cli-plugin-eslint/node_modules/eslint-loader/index.js??ref--13-0!/Users/gujiahao/Documents/work/github/artweb/src/utils/imagescale.js","dependencies":[{"path":"/Users/gujiahao/Documents/work/github/artweb/src/utils/imagescale.js","mtime":1588230106650},{"path":"/Users/gujiahao/Documents/work/github/artweb/node_modules/cache-loader/dist/cjs.js","mtime":1579587180818},{"path":"/Users/gujiahao/Documents/work/github/artweb/node_modules/thread-loader/dist/cjs.js","mtime":1579587183081},{"path":"/Users/gujiahao/Documents/work/github/artweb/node_modules/babel-loader/lib/index.js","mtime":1585810045725},{"path":"/Users/gujiahao/Documents/work/github/artweb/node_modules/@vue/cli-plugin-eslint/node_modules/eslint-loader/index.js","mtime":1579587173378}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.match\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/web.dom.iterable\";\n\n/**\n * 缩放算法\n * 最临邻近插值\n */\nfunction scale(data, width, height, newData, newWidth, newHeight) {\n  // 计算压缩后的缩放比\n  var scaleW = newWidth / width;\n  var scaleH = newHeight / height;\n  var dstData = newData;\n\n  var filter = function filter(dstCol, dstRow) {\n    var srcCol = Math.min(width - 1, dstCol / scaleW);\n    var srcRow = Math.min(height - 1, dstRow / scaleH);\n    var intCol = Math.floor(srcCol);\n    var intRow = Math.floor(srcRow); // 真实的index，因为数组是一维的\n\n    var dstI = dstRow * newWidth + dstCol;\n    var srcI = intRow * width + intCol; // rgba，所以要乘以4\n\n    dstI *= 4;\n    srcI *= 4;\n\n    for (var j = 0; j <= 3; j += 1) {\n      dstData[dstI + j] = data[srcI + j];\n    }\n  }; // 区块\n\n\n  for (var col = 0; col < newWidth; col += 1) {\n    for (var row = 0; row < newHeight; row += 1) {\n      filter(col, row);\n    }\n  }\n}\n\nfunction nearestNeighborInterpolation(imgData, newImgData) {\n  scale(imgData.data, imgData.width, imgData.height, newImgData.data, newImgData.width, newImgData.height);\n  return newImgData;\n}\n/**\n * 缩放算法\n * 双线性差值，会损坏原图（带低通滤波器效果）\n */\n\n/**\n * 获取某行某列的像素对于的rgba值\n * @param {Object} data 图像数据\n * @param {Number} srcWidth 宽度\n * @param {Number} srcHeight 高度\n * @param {Number} row 目标像素的行\n * @param {Number} col 目标像素的列\n * @returns {String} rgba 颜色值\n */\n\n\nfunction getRGBAValue(data, srcWidth, srcHeight, row, col) {\n  var newRow = row;\n  var newCol = col;\n\n  if (newRow >= srcHeight) {\n    newRow = srcHeight - 1;\n  } else if (newRow < 0) {\n    newRow = 0;\n  }\n\n  if (newCol >= srcWidth) {\n    newCol = srcWidth - 1;\n  } else if (newCol < 0) {\n    newCol = 0;\n  }\n\n  var newIndex = newRow * srcWidth + newCol;\n  newIndex *= 4;\n  return [data[newIndex + 0], data[newIndex + 1], data[newIndex + 2], data[newIndex + 3]];\n}\n\nfunction scale$1(data, width, height, newData, newWidth, newHeight) {\n  // 计算压缩后的缩放比\n  var scaleW = newWidth / width;\n  var scaleH = newHeight / height;\n  var dstData = newData;\n\n  var filter = function filter(dstCol, dstRow) {\n    // 源图像中的坐标（可能是一个浮点）\n    var srcCol = Math.min(width - 1, dstCol / scaleW);\n    var srcRow = Math.min(height - 1, dstRow / scaleH);\n    var intCol = Math.floor(srcCol);\n    var intRow = Math.floor(srcRow); // 计算u和v\n\n    var u = srcCol - intCol;\n    var v = srcRow - intRow; // 1-u与1-v\n\n    var u1 = 1 - u;\n    var v1 = 1 - v; // 真实的index，因为数组是一维的\n\n    var dstI = dstRow * newWidth + dstCol; // rgba，所以要乘以4\n\n    dstI *= 4;\n    var rgba00 = getRGBAValue(data, width, height, intRow + 0, intCol + 0);\n    var rgba01 = getRGBAValue(data, width, height, intRow + 0, intCol + 1);\n    var rgba10 = getRGBAValue(data, width, height, intRow + 1, intCol + 0);\n    var rgba11 = getRGBAValue(data, width, height, intRow + 1, intCol + 1);\n\n    for (var j = 0; j <= 3; j += 1) {\n      var partV = v * (u1 * rgba10[j] + u * rgba11[j]);\n      var partV1 = v1 * (u1 * rgba00[j] + u * rgba01[j]);\n      dstData[dstI + j] = partV + partV1;\n    }\n  };\n\n  for (var col = 0; col < newWidth; col += 1) {\n    for (var row = 0; row < newHeight; row += 1) {\n      filter(col, row);\n    }\n  }\n}\n\nfunction bilinearInterpolation(imgData, newImgData) {\n  scale$1(imgData.data, imgData.width, imgData.height, newImgData.data, newImgData.width, newImgData.height);\n  return newImgData;\n}\n/**\n * 缩放算法\n * 双立方（三次）卷积插值，图像更真实\n * 计算周围16个点\n * 取一阶导数值为二阶差分值的情况，满足插值函数一阶导函数连续\n * 函数逼近程度和三次样条插值效果一样，非常的高\n *\n * 公式：（矩阵乘法）\n * 推导公式\n * http://blog.csdn.net/qq_24451605/article/details/49474113\n * https://en.wikipedia.org/wiki/Bicubic_interpolation\n * */\n\n\nvar a00 = '';\nvar a01 = '';\nvar a02 = '';\nvar a03 = '';\nvar a10 = '';\nvar a11 = '';\nvar a12 = '';\nvar a13 = '';\nvar a20 = '';\nvar a21 = '';\nvar a22 = '';\nvar a23 = '';\nvar a30 = '';\nvar a31 = '';\nvar a32 = '';\nvar a33 = '';\n\nvar getRGBAValue$1 = function getRGBAValue(data, srcWidth, srcHeight, row, col, colorIndex) {\n  var newRow = row;\n  var newCol = col;\n\n  if (newRow >= srcHeight) {\n    newRow = srcHeight - 1;\n  } else if (newRow < 0) {\n    newRow = 0;\n  }\n\n  if (newCol >= srcWidth) {\n    newCol = srcWidth - 1;\n  } else if (newCol < 0) {\n    newCol = 0;\n  }\n\n  var newIndex = newRow * srcWidth + newCol;\n  newIndex *= 4;\n  return data[newIndex + colorIndex];\n};\n\nvar getPixelValue = function getPixelValue(pixelValue) {\n  var newPixelValue = pixelValue;\n  newPixelValue = Math.min(255, newPixelValue);\n  newPixelValue = Math.max(0, newPixelValue);\n  return newPixelValue;\n};\n\nvar updateCoefficients = function updateCoefficients(tmpPixels) {\n  var p = tmpPixels;\n  a00 = p[1][1];\n  a01 = -0.5 * p[1][0] + 0.5 * p[1][2];\n  a02 = p[1][0] - 2.5 * p[1][1] + 2 * p[1][2] - 0.5 * p[1][3];\n  a03 = -0.5 * p[1][0] + 1.5 * p[1][1] - 1.5 * p[1][2] + 0.5 * p[1][3];\n  a10 = -0.5 * p[0][1] + 0.5 * p[2][1];\n  a11 = 0.25 * p[0][0] - 0.25 * p[0][2] - 0.25 * p[2][0] + 0.25 * p[2][2];\n  a12 = -0.5 * p[0][0] + 1.25 * p[0][1] - p[0][2] + 0.25 * p[0][3] + 0.5 * p[2][0] - 1.25 * p[2][1] + p[2][2] - 0.25 * p[2][3];\n  a13 = 0.25 * p[0][0] - 0.75 * p[0][1] + 0.75 * p[0][2] - 0.25 * p[0][3] - 0.25 * p[2][0] + 0.75 * p[2][1] - 0.75 * p[2][2] + 0.25 * p[2][3];\n  a20 = p[0][1] - 2.5 * p[1][1] + 2 * p[2][1] - 0.5 * p[3][1];\n  a21 = -0.5 * p[0][0] + 0.5 * p[0][2] + 1.25 * p[1][0] - 1.25 * p[1][2] - p[2][0] + p[2][2] + 0.25 * p[3][0] - 0.25 * p[3][2];\n  a22 = p[0][0] - 2.5 * p[0][1] + 2 * p[0][2] - 0.5 * p[0][3] - 2.5 * p[1][0] + 6.25 * p[1][1] - 5 * p[1][2] + 1.25 * p[1][3] + 2 * p[2][0] - 5 * p[2][1] + 4 * p[2][2] - p[2][3] - 0.5 * p[3][0] + 1.25 * p[3][1] - p[3][2] + 0.25 * p[3][3];\n  a23 = -0.5 * p[0][0] + 1.5 * p[0][1] - 1.5 * p[0][2] + 0.5 * p[0][3] + 1.25 * p[1][0] - 3.75 * p[1][1] + 3.75 * p[1][2] - 1.25 * p[1][3] - p[2][0] + 3 * p[2][1] - 3 * p[2][2] + p[2][3] + 0.25 * p[3][0] - 0.75 * p[3][1] + 0.75 * p[3][2] - 0.25 * p[3][3];\n  a30 = -0.5 * p[0][1] + 1.5 * p[1][1] - 1.5 * p[2][1] + 0.5 * p[3][1];\n  a31 = 0.25 * p[0][0] - 0.25 * p[0][2] - 0.75 * p[1][0] + 0.75 * p[1][2] + 0.75 * p[2][0] - 0.75 * p[2][2] - 0.25 * p[3][0] + 0.25 * p[3][2];\n  a32 = -0.5 * p[0][0] + 1.25 * p[0][1] - p[0][2] + 0.25 * p[0][3] + 1.5 * p[1][0] - 3.75 * p[1][1] + 3 * p[1][2] - 0.75 * p[1][3] - 1.5 * p[2][0] + 3.75 * p[2][1] - 3 * p[2][2] + 0.75 * p[2][3] + 0.5 * p[3][0] - 1.25 * p[3][1] + p[3][2] - 0.25 * p[3][3];\n  a33 = 0.25 * p[0][0] - 0.75 * p[0][1] + 0.75 * p[0][2] - 0.25 * p[0][3] - 0.75 * p[1][0] + 2.25 * p[1][1] - 2.25 * p[1][2] + 0.75 * p[1][3] + 0.75 * p[2][0] - 2.25 * p[2][1] + 2.25 * p[2][2] - 0.75 * p[2][3] - 0.25 * p[3][0] + 0.75 * p[3][1] - 0.75 * p[3][2] + 0.25 * p[3][3];\n};\n\nvar getValue = function getValue(x, y) {\n  var x2 = x * x;\n  var x3 = x2 * x;\n  var y2 = y * y;\n  var y3 = y2 * y;\n  return a00 + a01 * y + a02 * y2 + a03 * y3 + (a10 + a11 * y + a12 * y2 + a13 * y3) * x + (a20 + a21 * y + a22 * y2 + a23 * y3) * x2 + (a30 + a31 * y + a32 * y2 + a33 * y3) * x3;\n};\n\nfunction scale$2(data, width, height, newData, newWidth, newHeight) {\n  var dstData = newData; // 计算压缩后的缩放比\n\n  var scaleW = newWidth / width;\n  var scaleH = newHeight / height;\n\n  var filter = function filter(dstCol, dstRow) {\n    // 源图像中的坐标（可能是一个浮点）\n    var srcCol = Math.min(width - 1, dstCol / scaleW);\n    var srcRow = Math.min(height - 1, dstRow / scaleH);\n    var intCol = Math.floor(srcCol);\n    var intRow = Math.floor(srcRow); // 计算u和v\n\n    var u = srcCol - intCol;\n    var v = srcRow - intRow; // 真实的index，因为数组是一维的\n\n    var dstI = dstRow * newWidth + dstCol;\n    dstI *= 4; // 16个邻近像素的灰度（分别计算成rgba）\n\n    var tmpPixels = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]; // rgba\n\n    for (var i = 0; i <= 3; i += 1) {\n      // 16个临近点\n      for (var m = -1; m <= 2; m += 1) {\n        for (var n = -1; n <= 2; n += 1) {\n          tmpPixels[m + 1][n + 1] = getRGBAValue$1(data, width, height, intRow + m, intCol + n, i);\n        }\n      } // 更新系数\n\n\n      updateCoefficients(tmpPixels); // 利用uv来求值\n\n      dstData[dstI + i] = getPixelValue(getValue(v, u));\n    }\n  }; // 区块\n\n\n  for (var col = 0; col < newWidth; col += 1) {\n    for (var row = 0; row < newHeight; row += 1) {\n      filter(col, row);\n    }\n  }\n}\n\nfunction bicubicInterpolation(imgData, newImgData) {\n  scale$2(imgData.data, imgData.width, imgData.height, newImgData.data, newImgData.width, newImgData.height);\n  return newImgData;\n}\n/**\n * 缩放算法\n * 双立方（三次）卷积插值，图像更真实\n * 计算周围16个点\n * 取一阶导数值为二阶差分值的情况，满足插值函数一阶导函数连续\n * 函数逼近程度和三次样条插值效果一样，非常的高\n *\n * 公式：（矩阵乘法）\n * 推导公式\n * http://blog.csdn.net/qq_24451605/article/details/49474113\n * https://en.wikipedia.org/wiki/Bicubic_interpolation\n * */\n\n/**\n * 采样公式的常数A取值,调整锐化与模糊\n * -0.5 三次Hermite样条\n * -0.75 常用值之一\n * -1 逼近y = sin(x*PI)/(x*PI)\n * -2 常用值之一\n */\n\n\nvar A = -1;\n\nfunction interpolationCalculate(x) {\n  var absX = x >= 0 ? x : -x;\n  var x2 = x * x;\n  var x3 = absX * x2;\n\n  if (absX <= 1) {\n    return 1 - (A + 3) * x2 + (A + 2) * x3;\n  }\n\n  if (absX <= 2) {\n    return -4 * A + 8 * A * absX - 5 * A * x2 + A * x3;\n  }\n\n  return 0;\n}\n\nfunction getPixelValue$1(pixelValue) {\n  var newPixelValue = pixelValue;\n  newPixelValue = Math.min(255, newPixelValue);\n  newPixelValue = Math.max(0, newPixelValue);\n  return newPixelValue;\n}\n/**\n * 获取某行某列的像素对于的rgba值\n * @param {Object} data 图像数据\n * @param {Number} srcWidth 宽度\n * @param {Number} srcHeight 高度\n * @param {Number} row 目标像素的行\n * @param {Number} col 目标像素的列\n * @returns {String} rgba值\n */\n\n\nfunction getRGBAValue$2(data, srcWidth, srcHeight, row, col) {\n  var newRow = row;\n  var newCol = col;\n\n  if (newRow >= srcHeight) {\n    newRow = srcHeight - 1;\n  } else if (newRow < 0) {\n    newRow = 0;\n  }\n\n  if (newCol >= srcWidth) {\n    newCol = srcWidth - 1;\n  } else if (newCol < 0) {\n    newCol = 0;\n  }\n\n  var newIndex = newRow * srcWidth + newCol;\n  newIndex *= 4;\n  return [data[newIndex + 0], data[newIndex + 1], data[newIndex + 2], data[newIndex + 3]];\n}\n\nfunction scale$3(data, width, height, newData, newWidth, newHeight) {\n  var dstData = newData; // 计算压缩后的缩放比\n\n  var scaleW = newWidth / width;\n  var scaleH = newHeight / height;\n\n  var filter = function filter(dstCol, dstRow) {\n    // 源图像中的坐标（可能是一个浮点）\n    var srcCol = Math.min(width - 1, dstCol / scaleW);\n    var srcRow = Math.min(height - 1, dstRow / scaleH);\n    var intCol = Math.floor(srcCol);\n    var intRow = Math.floor(srcRow); // 计算u和v\n\n    var u = srcCol - intCol;\n    var v = srcRow - intRow; // 真实的index，因为数组是一维的\n\n    var dstI = dstRow * newWidth + dstCol;\n    dstI *= 4; // 存储灰度值的权重卷积和\n\n    var rgbaData = [0, 0, 0, 0]; // 根据数学推导，16个点的f1*f2加起来是趋近于1的（可能会有浮点误差）\n    // 因此就不再单独先加权值，再除了\n    // 16个邻近点\n\n    for (var m = -1; m <= 2; m += 1) {\n      for (var n = -1; n <= 2; n += 1) {\n        var rgba = getRGBAValue$2(data, width, height, intRow + m, intCol + n); // 一定要正确区分 m,n和u,v对应的关系，否则会造成图像严重偏差（譬如出现噪点等）\n        // F(row + m, col + n)S(m - v)S(n - u)\n\n        var f1 = interpolationCalculate(m - v);\n        var f2 = interpolationCalculate(n - u);\n        var weight = f1 * f2;\n        rgbaData[0] += rgba[0] * weight;\n        rgbaData[1] += rgba[1] * weight;\n        rgbaData[2] += rgba[2] * weight;\n        rgbaData[3] += rgba[3] * weight;\n      }\n    }\n\n    dstData[dstI + 0] = getPixelValue$1(rgbaData[0]);\n    dstData[dstI + 1] = getPixelValue$1(rgbaData[1]);\n    dstData[dstI + 2] = getPixelValue$1(rgbaData[2]);\n    dstData[dstI + 3] = getPixelValue$1(rgbaData[3]);\n  }; // 区块\n\n\n  for (var col = 0; col < newWidth; col += 1) {\n    for (var row = 0; row < newHeight; row += 1) {\n      filter(col, row);\n    }\n  }\n}\n\nfunction bicubicInterpolation$1(imgData, newImgData) {\n  scale$3(imgData.data, imgData.width, imgData.height, newImgData.data, newImgData.width, newImgData.height);\n  return newImgData;\n}\n\nfunction extend(target) {\n  var finalTarget = target;\n\n  for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    rest[_key - 1] = arguments[_key];\n  }\n\n  rest.forEach(function (source) {\n    source && Object.keys(source).forEach(function (key) {\n      finalTarget[key] = source[key];\n    });\n  });\n  return finalTarget;\n}\n/**\n * 选择这段代码用到的太多了，因此抽取封装出来\n * @param {Object} element dom元素或者selector\n * @return {HTMLElement} 返回选择的Dom对象，无果没有符合要求的，则返回null\n */\n\n/**\n * 获取DOM的可视区高度，兼容PC上的body高度获取\n * 因为在通过body获取时，在PC上会有CSS1Compat形式，所以需要兼容\n * @param {HTMLElement} dom 需要获取可视区高度的dom,对body对象有特殊的兼容方案\n * @return {Number} 返回最终的高度\n */\n\n/**\n * 设置一个Util对象下的命名空间\n * @param {Object} parent 需要绑定到哪一个对象上\n * @param {String} namespace 需要绑定的命名空间名\n * @param {Object} target 需要绑定的目标对象\n * @return {Object} 返回最终的对象\n */\n\n\nvar defaultArgs = {\n  width: 80,\n  height: 80,\n  mime: 'image/png',\n  // 0: nearestNeighbor\n  // 1: bilinearInterpolation\n  // 2: bicubicInterpolation\n  // 3: bicubicInterpolation2\n  processType: 1\n};\nvar defaultArgsCompress = {\n  // 压缩质量\n  quality: 0.92,\n  mime: 'image/jpeg',\n  // 压缩时的放大系数，默认为1，如果增大，代表图像的尺寸会变大(最大不会超过原图)\n  compressScaleRatio: 1,\n  // ios的iPhone下主动放大一定系数以解决分辨率过小的模糊问题\n  iphoneFixedRatio: 1.5,\n  // 是否采用原图像素（不会改变大小）\n  isUseOriginSize: false,\n  // 增加最大宽度，增加后最大不会超过这个宽度\n  maxWidth: 0,\n  // 使用强制的宽度，如果使用，其它宽高比系数都会失效，默认整图使用这个宽度\n  forceWidth: 0,\n  // 同上，但是一般不建议设置，因为很可能会改变宽高比导致拉升，特殊场景下使用\n  forceHeight: 0\n};\n\nfunction scaleMixin(ImageScale) {\n  var api = ImageScale;\n  /**\n   * 对ImageData类型的数据进行缩放，将数据放入新的imageData中\n   * @param {ImageData} imageData 目标ImageData\n   * @param {ImageData} newImageData 新的ImageData\n   * @param {Object} args 额外参数\n   */\n\n  api.scaleImageData = function scaleImageData(imageData, newImageData, args) {\n    var finalArgs = extend({}, defaultArgs, args);\n    var processTypes = [nearestNeighborInterpolation, bilinearInterpolation, bicubicInterpolation, bicubicInterpolation$1];\n    var curDealFunc = processTypes[finalArgs.processType];\n    curDealFunc(imageData, newImageData);\n  };\n  /**\n   * 对Image类型的对象进行缩放，返回一个base64字符串\n   * @param {Image} image 目标Image\n   * @param {Object} args 额外参数\n   * @return {String} 返回目标图片的b64字符串\n   */\n\n\n  api.scaleImage = function scaleImage(image, args) {\n    var width = image.width;\n    var height = image.height;\n    var finalArgs = extend({}, defaultArgs, args);\n    var canvasTransfer = document.createElement('canvas');\n    var ctxTransfer = canvasTransfer.getContext('2d');\n    canvasTransfer.width = width;\n    canvasTransfer.height = height;\n    ctxTransfer.drawImage(image, 0, 0, width, height);\n    var imageData = ctxTransfer.getImageData(0, 0, width, height);\n    var newImageData = ctxTransfer.createImageData(finalArgs.width, finalArgs.height);\n    api.scaleImageData(imageData, newImageData, finalArgs);\n    canvasTransfer.width = newImageData.width;\n    canvasTransfer.height = newImageData.height;\n    ctxTransfer.putImageData(newImageData, 0, 0, 0, 0, canvasTransfer.width, canvasTransfer.height); // console.log(imageData);\n    // console.log(newImageData);\n    // console.log('压缩时w:' + canvasTransfer.width + ',' + canvasTransfer.height);\n\n    return canvasTransfer.toDataURL(finalArgs.mime, 0.9);\n  };\n\n  function getPixelRatio(context) {\n    var backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;\n    var ratio = (window.devicePixelRatio || 1) / backingStore;\n    return ratio;\n  }\n  /**\n   * 压缩图片，返回一个base64字符串\n   * 与scale的区别是这用的是canvas默认缩放，并且有很多参数可控\n   * @param {Image} image 目标Image\n   * @param {Object} args 额外参数\n   * @return {String} 返回目标图片的b64字符串\n   */\n\n\n  api.compressImage = function compressImage(image, args) {\n    var width = image.width;\n    var height = image.height;\n    var wPerH = width / height;\n    var finalArgs = extend({}, defaultArgsCompress, args);\n    var canvasTransfer = document.createElement('canvas');\n    var ctxTransfer = canvasTransfer.getContext('2d');\n    var ratio = getPixelRatio(ctxTransfer);\n    ratio *= finalArgs.compressScaleRatio || 1;\n\n    if (navigator.userAgent.match(/(iPhone\\sOS)\\s([\\d_]+)/)) {\n      ratio *= finalArgs.iphoneFixedRatio || 1;\n    }\n\n    var finalWidth = window.innerWidth * ratio;\n\n    if (finalArgs.isUseOriginSize || finalWidth > width) {\n      // 最大不会超过原图的尺寸\n      finalWidth = width;\n    }\n\n    var maxWidth = finalArgs.maxWidth;\n\n    if (maxWidth && width > maxWidth && finalWidth > maxWidth) {\n      // 考虑到之前已经进行不超过原图的判断了\n      finalWidth = maxWidth;\n    }\n\n    var forceWidth = finalArgs.forceWidth;\n    var forceHeight = finalArgs.forceHeight;\n\n    if (forceWidth) {\n      // 使用固定宽\n      finalWidth = forceWidth;\n    }\n\n    var finalHeight = finalWidth / wPerH;\n\n    if (forceHeight) {\n      finalHeight = forceHeight;\n    }\n\n    canvasTransfer.width = finalWidth;\n    canvasTransfer.height = finalHeight;\n    ctxTransfer.drawImage(image, 0, 0, width, height, 0, 0, canvasTransfer.width, canvasTransfer.height);\n    return canvasTransfer.toDataURL(finalArgs.mime, finalArgs.quality);\n  };\n}\n\nvar ImageScale = {};\nscaleMixin(ImageScale);\nexport default ImageScale;",null]}